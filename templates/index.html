<!DOCTYPE html>

<html>
<head>
<title>
   Stimmungskompass
  </title>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <link rel="icon" href="{{ favicon() }}" type="image/x-icon">
<!-- Leaflet CSS -->
<link href="http://cdn.leafletjs.com/leaflet/v1.7.1/leaflet.css" rel="stylesheet"/>
<!-- Leaflet JavaScript -->
<script src="http://cdn.leafletjs.com/leaflet/v1.7.1/leaflet.js">
</script>
<!-- Leaflet Draw CSS -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" rel="stylesheet"/>
<!-- Leaflet Draw JavaScript -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js">
</script>
<!-- Heatmap plugin -->
<!-- JQuery -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js">
</script>

<!-- Include Spectrum's CSS from CDN -->
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.css" />

<!-- Include Spectrum's JavaScript from CDN -->
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.js"></script>

<style type="text/css">
   body { background-color: #1b1b1b; }
  </style>
<!-- The categories will be loaded from 'categories.html' -->
<iframe id="categories-frame" src="/categories" style="display:none;">
</iframe>


</head>
<style>
  /* BASIC CSS START */
body, html {
    margin: 0;
    padding: 0;
    overflow: hidden; /* Prevent scrolling */
    box-sizing: border-box; /* Include padding and border in the element's total width and height */
    font-family: 'Roboto', sans-serif !important;
}

*, *:before, *:after {
    box-sizing: inherit; /* Inherit box-sizing */
}

/* Desktop Styles */
@media (min-width: 768px) {
    #map, #sidebar {
        position: absolute;
        top: 15px;
        bottom: 15px;
        border-radius: 30px;
        overflow: hidden;
    }

    #map {
        left: 15px;
        right: calc(30% + 15px);
    }

    #sidebar {
        width: calc(30% - 15px);
        right: 15px;
        background: #111111;
        padding: 10px;
    }
}




#map {
    left: 15px; /* Consistent margin from the left */
    right: calc(30% + 15px); /* Adjusting for sidebar width and margin */
}

#sidebar {
    width: calc(30% - 15px); /* Sidebar takes up 30% width minus right margin */
    right: 15px; /* Consistent margin from the right */
    background: #111111;
    padding: 10px;
}


/* CUSTOM SCROLLBAR CSS START */
/* For Webkit (Chrome, Safari, Edge) */
::-webkit-scrollbar {
    display: none; /* Hide scrollbar for Webkit browsers */
}

/* Hide scrollbar for IE, Edge, and Firefox */
body {
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
}

/* Hide scrollbar for Chrome, Safari and Opera */
body::-webkit-scrollbar {
    display: none;
}

.leaflet-draw-edit-edit {
        display: none !important;
    }

/* CUSTOM SCROLLBAR CSS END */

/* CITY PICTURE CSS START */
.logo-img {
max-width: 100%;
width: 100%;
box-sizing: border-box;
height: auto;
display: block;
margin-left:auto;
margin-right:auto;
margin-top: 3px;
margin-bottom: 8px; 
border-radius: 30px;"
}
/* CITY PICTURE CSS END */

/* LEAFLET MAP PILL CSS */
.leaflet-bar, .leaflet-draw-section, .leaflet-draw-section {
  border-radius: 30px !important;
  border: none;
  background-color: var(--leaflet-control-bg-dark) !important; /* Use variable */
}

/* LEAFLET MAP ICONS CSS */
.leaflet-control-zoom-in, .leaflet-control-zoom-out, .leaflet-draw-draw-polyline, .leaflet-draw-draw-polygon, .leaflet-draw-draw-rectangle, .leaflet-draw-draw-circle, .leaflet-draw-draw-marker, .leaflet-draw-draw-circlemarker, .leaflet-draw-edit-edit, .leaflet-draw-edit-remove {
  background-color: var(--leaflet-control-bg-dark) !important; /* Use variable */
  color: var(--leaflet-control-color-dark) !important; /* Use variable */
  border: none !important;
  font-size: 18px !important;
  line-height: 30px !important;
  width: 30px !important;
  height: 30px !important;
}

.leaflet-draw-draw-rectangle {
  background-image: url('rectangle_darkmode_svg.svg'); /* Replace with the path to your new icon */
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
}
/* LEAFLET MAP ICONS CSS END */

:root {
  --leaflet-control-bg-dark: #3a3a3a; /* Dark mode background color */
  --leaflet-control-color-dark: white; /* Dark mode symbol color */
  --leaflet-control-bg-light: #f3f4f8; /* Light mode background color */
  --leaflet-control-color-light: black; /* Light mode symbol color */
}

.leaflet-draw-draw-marker {
display: none !important;
}

.leaflet-draw-draw-polyline {
display: none !important;
}

.leaflet-draw-draw-circlemarker {
display: none !important;
}

/* LEAFLET MAP ICON COLOR CHANGE WHEN DISABLED CSS START */
.leaflet-disabled {
  background-color: var(--leaflet-disabled-bg) !important;
  color: var(--leaflet-disabled-color) !important;
}

/* LEAFLET MAP ICON COLOR CHANGE WHEN DISABLED CSS END */



/* LEAFLET MAP ICON BORDER REMOVAL CSS START */
.leaflet-control-zoom-in, .leaflet-control-zoom-out {
  border-top: none !important;
  border-bottom: none !important;
  border-radius: 0 !important;
}
/* LEAFLET MAP ICON BORDER REMOVAL CSS END */



/* LEAFLET MAP ICON MISC CSS START */
.leaflet-bar > a:first-child {
  border-top-left-radius: 30px !important;
  border-top-right-radius: 30px !important;
}

.leaflet-bar > a:last-child {
  border-bottom-left-radius: 30px !important;
  border-bottom-right-radius: 30px !important;
}


.leaflet-control-layers-toggle {
    font-size: 30px;
    line-height: 24px;
    font-weight: bold;
    text-align: center;
    border-radius: 30px;
    background-color: transparent;
    background-repeat: no-repeat;
    background-position: center;
    width: 36px;
    height: 36px;
}

.leaflet-control-layers {
    border-radius: 30px;
    opacity: 1;
}

.leaflet-control-layers::before {
    content: "";
    background-image: var(--leaflet-control-layers-before-bg);
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: 30px;
    background-size: cover;
    opacity: 1;
}

.leaflet-control-layers-expanded {
    background-color: var(--leaflet-control-layers-expanded-bg) !important;
    color: var(--leaflet-control-layers-expanded-text) !important;
}


/* Hide the background image when the control layers menu is expanded */
.leaflet-control-layers-expanded::before {
    content: none !important;
}

.leaflet-control-layers-expanded .leaflet-control-layers-list {
    color: var(--leaflet-control-layers-list-text) !important;
    font-size: 15px;
    font-weight: bold;
    padding: 10px;  /* Added padding here */
}

.leaflet-control-layers-selector {
    color: var(--leaflet-control-layers-selector-text) !important;
    margin: 2px !important;
}

.leaflet-popup .leaflet-popup-content-wrapper .leaflet-popup-content {
    font-size: 25px !important;
}

/* Your existing rules for .leaflet-control-layers and .leaflet-top leaflet-right had typos, corrected below */
.leaflet-control-layers.leaflet-control {
    border-radius: 30px;
}

.leaflet-top.leaflet-right {
    border-radius: 50px;
}

    .leaflet-popup-content-wrapper {
    background-color: var(--popup-bg-color) !important;
    color: var(--popup-text-color) !important;
    border-radius: 30px !important;
}

   .leaflet-popup-content {
    color: var(--popup-text-color) !important;
}

.leaflet-popup-tip {
    display: block; /* Optional: hides the tip arrow for a cleaner look */
    background-color: var(--popup-bg-color) !important;
}
	
	  .leaflet-popup-close-button {
        display: none; /* Optional: hides the tip arrow for a cleaner look */

    }
	
  

   #shape-note {
        border-radius: 10px;
		border:none;
        display: block;
		color: #111111;
        width: 100%;
        box-sizing: border-box;
        max-height: 200px;
		height: 75px;
		padding: 5px;
		max-width: 100%;
        margin-bottom: -25px; /* Adjust this value as needed to reduce gap */
		font-size: 15px; /* Set font size to 15px */
        font-family: 'Roboto', sans-serif; /* Set font family to Roboto */
    }


#shape-note::-webkit-input-placeholder { /* Chrome, Opera, Safari */
    color: #111111;
    opacity: 1; /* Override any default opacity */
}

#shape-note:-ms-input-placeholder { /* Internet Explorer 10-11 */
    color: #111111;
    opacity: 1; /* Override any default opacity */
}

#shape-note::-ms-input-placeholder { /* Microsoft Edge */
    color: #111111;
    opacity: 1; /* Override any default opacity */
}

#shape-note::placeholder { /* Most modern browsers */
    color: #111111;
    opacity: 1; /* Override any default opacity */
}

    #save-note, #cancel-note {
        background-color: #4CAF50; /* Green for save, red for cancel */
        border: none;
        color: white;
        padding: 10px 20px;
        border-radius: 30px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.2s ease-in-out;
        margin-top: 0; /* Remove top margin to reduce gap */
    }

    #cancel-note {
        background-color: #B71C1C;
        margin-left: 50px; /* Adjust this value as needed */
    }

    #save-note:hover {
        background-color: #388E3C; /* Darker green for hover effect */
    }

    #cancel-note:hover {
        background-color: #D32F2F; /* Darker red for hover effect */
    }

/* LEAFLET MAP ICON MISC CSS END */



/* SMALL OPTIONS MENU TOP BUTTON CSS START */
/* This CSS makes sure the "smalloptionsmenutop" entity is resized properly */
 .smalloptionsmenutop {
      display: flex;
      justify-content: space-between;
    }
    .left-container, .right-container {
      display: flex;
      align-items: center;
    }
    .pinlist-div, .info-div, .lightswitch-div, .key-div {
      margin: 0 3px;
    }
}

  
    /* Individual icon divs */
    .lightswitch-div, .key-div, .pinlist-div, .info-div {
      flex-direction: row;
    }

    /* Make the containers hidden when screen width is less than 1271px */
    @media (max-width: 1271px) and (min-width: 780px) {
	  .left-container, .right-container, .togglebuttoncontainer {
		display: none;
	  }
	}
	
		/* Icon scaler */
        #keyDiv {
            cursor: pointer;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center; /* Vertically center the image */
        }

        #keyDiv img {
            max-width: 40px;  /* Adjust size as needed */
            height: auto;
            border-radius: 30px;
            margin: 0;
        }
		
        #infoDiv {
            cursor: pointer;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center; /* Vertically center the image */
        }

        #infoDiv img {
            max-width: 40px;  /* Adjust size as needed */
            height: auto;
            border-radius: 30px;
            margin: 0;
        }
		
        #pinlistdiv {
            cursor: pointer;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center; /* Vertically center the image */
        }

        #pinlistdiv img {
            max-width: 40px;  /* Adjust size as needed */
            height: auto;
            border-radius: 30px;
            margin: 0;
        }
		
        #lightswitchDiv {
            cursor: pointer;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center; /* Vertically center the image */
        }

        #lightswitchDiv img {
            max-width: 40px;  /* Adjust size as needed */
            height: auto;
            border-radius: 30px;
            margin: 0;
        }
/* SMALL OPTIONS MENU BUTTON CSS END */


/* BUTTON MAIN UNIVERSAL CSS START */
.button-u {
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 14px 0;
    padding: 15px;
    box-sizing: border-box;
    cursor: pointer;
    text-decoration: none;
	    white-space: normal;
    border-radius: 30px;
    transition: background-color 0.2s ease-in-out;
    color: white;
    text-align: center;
    line-height: 1;
    max-height: 40px;
    width: 100%;
}
/* BUTTON MAIN UNIVERSAL CSS END */



/* BUTTON SMALL SIDEBAR CSS START */
/* This button is used mainly for Wie funktionierts. */
.button-s {
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 14px 0;
    padding: 15px;
    box-sizing: border-box;
    cursor: pointer;
    text-decoration: none;
	    white-space: normal;
    border-radius: 30px;
    transition: background-color 0.2s ease-in-out;
    color: white;
    text-align: center;
    line-height: 1;
    max-height: 40px;
    width: 100%;
}
/* BUTTON SMALL SIDEBAR CSS END */
  /* HOVER AND SELECTED BUTTON EFFECT CSS START */
        /* Hover effect */
        .button-s:hover,
        .categorybutton:hover,
        .save-note:hover,
        .key-div:hover,
        .pinlist-div:hover,
        .info-div:hover,
        .lightswitch-div:hover {
            filter: brightness(85%) !important;
            outline: 3px solid var(--border-hover-color) !important; /* Use custom property for outline color */
            outline-offset: -3px !important; /* Offset to align with the border edge */
        }


/* INFO-POPUP CONTAINER CSS START */
/* Takes care of how big the info-popup is gonna be. This popup shows information about each element on the website. */
    #info-popup {
        padding: 20px;
        max-width: 500px;
        font-size: 14px;
        z-index: 1000;  /* Make sure the popup appears above the map */
    }
#info-popup.admin-pindelete-popup {
    max-width: 300px;
}
	
	#info-popup.uigif-counter-popup {
    max-width: 320px;
}

#info-popup.uigif-counter-popup img {
    border-radius: 30px;
}

#info-popup.admin-pinresize-popup {
 max-width: 300px;
}
/* INFO-POPUP CONTAINER CSS END */

.count-pill {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    padding: 10px;
    border-radius: 30px;
    background-color: white;
    box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
    z-index: 10;
}

.color-circle {
    height: 15px;
    width: 15px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 10px; /* Adjust as needed */
}

.category-symbol {
    height: 25px;
    width: 25px;
    margin-right: 10px; /* Adjust as needed */
}

#counter-pill {
    position: absolute;
    top: 4.5%;
    left: 50%;
	outline: 2px solid rgba(0,0,0,0.2);
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 30px;
    padding: 8px 12px; /* Increased left and right padding */
    z-index: 10000;
    font-size: 25px;
    font-weight: bold;
    gap: 5px;
    background-color: var(--counter-pill-bg-color);
    color: var(--counter-pill-text-color);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.counter-color {
    height: 25px; /* Adjusted to match desktop version */
    width: 25px; /* Adjusted to match desktop version */
    border-radius: 50%;
    display: inline-block;
    margin-right: 5px; /* Consistent space after the circle */
}

#color-counters, #category-counters {
    display: flex;
    padding: 0;
    margin: 0;
    gap: 5px;
}

#color-counters li, #category-counters li {
    flex-grow: 1; /* Allow each item to grow to fill available space */
    flex-shrink: 1; /* Allow each item to shrink if needed */
    display: flex; /* Make the list items flex containers */
    justify-content: center; /* Center the content horizontally */
    align-items: center; /* Center the content vertically */
    max-height: 100%; /* Ensure items do not exceed the pill's height */
}

/* Adjust the size of the content (icons, text, etc.) inside the list items */
#color-counters li > *, #category-counters li > * {
    max-height: 100%; /* Adjusted to allow full height */
    max-width: 100%; /* Adjusted to allow full width */
    font-size: 25px; /* Consistent font size with the pill */
}


.hidden {
    display: none !important; // !important to override any other display property
}
#popup-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 30px;
    background-color: rgba(0, 0, 0, 0.5); /* Overlay background */
    z-index: 1000; /* Ensure it's above other content */
}

#popup-content {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    max-width: calc(100% - 20px); /* Max width, minus the gap */
    max-height: calc(100% - 20px); /* Max height, minus the gap */
    width: 400px;
    height: 300px;
    background: #fff;
    padding: 20px;
    border-radius: 30px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    z-index: 1001; /* Above the overlay */
    overflow: auto; /* Add scroll for small screens */
}

#popup-content button {
    position: absolute;
    top: 10px;
    right: 10px;
}

#close-popup {
    position: absolute;
    top: 0;
    right: 0;
    padding: 0.5em;
    border: none;
    background-color: transparent;
    font-size: 1em;
    cursor: pointer;
    z-index: 1002;
}

@media screen and (max-width: 420px) {
    #popup-content {
        width: auto; /* Adjust width for very small screens */
    }
}

.dismiss-button {
    border-radius: 30px;
	margin-right: 50px;
    /* Add other styling as needed, e.g., padding, border, background-color, etc. */
}

#popup-text .ql-align-center {
  text-align: center;
}

#popup-text .ql-font-serif {
  font-family: 'Times New Roman', serif;
}

#popup-text .ql-align-right {
  text-align: right;
}

#popup-text .ql-align-justify {
  text-align: justify;
}

#popup-text .ql-align-center {
  text-align: center;
}

#popup-text img {
  max-width: 95%;  /* Ensures the image does not exceed the width of the popup */
  height: auto;     /* Maintains the aspect ratio of the image */
  display: block;   /* Allows margin auto to work for horizontal centering */
  margin: 0 auto;
  border-radius: 30px; /* Centers the image horizontally */
}

/* Hide all cursors inside the map when marker drawing is active */
.no-cursor .leaflet-container,
.no-cursor .leaflet-container * {
    cursor: none !important;
}

/* Hide the Leaflet draw tooltip */
.leaflet-draw-tooltip {
    display: none !important;
}

:root {
    /* Define default dark mode colors */
    --counter-pill-bg-color: #111111;
    --counter-pill-text-color: white;
}

.light-mode {
    /* Define light mode colors */
    --counter-pill-bg-color: #f3f4f8;
    --counter-pill-text-color: black;
}

 .leaflet-draw-draw-polyline, .leaflet-draw-draw-polygon, .leaflet-draw-draw-rectangle, .leaflet-draw-draw-circle, .leaflet-draw-draw-marker, .leaflet-draw-draw-circlemarker, .leaflet-draw-edit-edit, .leaflet-draw-section {
  visibility: hidden; /* Hide the icons */
}
/* Tool selection popup styling */
#tool-selection-popup {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: rgba(211, 211, 211, 0.05);
    border-radius: 35px;
    padding: 10px;
    gap: 10px;
    box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.2);
    flex-wrap: nowrap;
    max-width: 50%;
    z-index: 2;
}

.container {
    position: relative; /* Ensures that child absolute elements are positioned relative to this */
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 1; /* Ensures the container is above other content */
}



/* Styles for tool buttons inside the popup */
.tool-btn {
    background-color: transparent;
    border: none;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

.tool-btn img {
    display: block;
    width: auto;
    height: 40px;
    transition: transform 0.2s;
}

.tool-btn:hover img {
    transform: scale(1.1);
    outline: 3px solid white;
}

.tool-btn.selected img {
    outline: 5px solid white;
}

.filter-container {
    display: flex;
    justify-content: center; /* Center items horizontally */
    flex-wrap: wrap; /* Allow items to wrap onto the next line */
    gap: 10px; /* Optional: add some space between elements */
}

/* If elements wrap, they should take the full width of the line */
.filter-container > * {
    flex-basis: 100%;
}
.type-filter {
margin-bottom: 50px;
}


 </style>
<style>

/* Mobile Styles */
@media (max-width: 767px) {
    body, html {
        padding-left: 15px;
        padding-right: 15px;
    }
	
	#tool-selection-popup {
	max-width: 70%;
	margin-top: -2.5px !important;
			margin-bottom: 7.5px;
	}


    #map {
        position: absolute;
        top: calc(9vh + 35px); /* Estimate based on viewport height and gap */
        bottom: 165px; /* Adjust for the fixed height of the sidebar (150px + 15px gap) */
        left: 15px;
        right: 15px;
        border-radius: 30px;
        margin-bottom: 15px;
		margin-top: 7.5px !important;
    }

    #sidebar {
        position: fixed;
        height: 150px;
        bottom: 0;
        left: 15px !important;
        right: 15px !important;
        border-radius: 30px;
        margin-bottom: 15px;
        overflow: hidden;
		width: auto;
    }

#sidebar-mobileheader {
    position: fixed;
    top: 15px;
    left: 15px;
    right: 15px;
    margin-bottom: 15px !important;
    border-radius: 30px;
    padding-right: 15px;
    padding-left: 15px;
    padding: 7.5px;
    max-height: 81px;
    z-index: 1001; /* High z-index */
    background-color: red; /* Bright background color for testing */
    width: auto; /* Fixed width for testing */
    display: block !important; /* Force display */
}

#sidebar-mobileheader img {
    display: block; /* Use block display for the image */
    max-width: 100%; /* Limit image width to container width */
    max-height: 64px; /* Maximum height for the image */
    height: auto; /* Adjust height automatically */
    width: auto; /* Adjust width automatically */
    margin: auto; /* Center the image if needed */
    object-fit: contain; /* Ensure aspect ratio is maintained without stretching */
}


    .hide-on-mobile {
        display: none !important;
    }

    .appear-on-mobile {
        display: block !important;
    }
}

@media (max-width: 768px) {
    #counter-pill {
        padding: 8px 12px; /* Increased left and right padding */
        font-size: 3vw;
        top: 7.5%;
        max-width: 60%;
    }
	
	.counter-color {
    height: 12px;
    width: 12px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 5px; /* Reduced space after the circle */
}



    #color-counters, #category-counters {
        display: flex;
        padding: 0;
        margin: 0;
        gap: 5px;
    }

    #color-counters li, #category-counters li {
        flex-grow: 1; /* Allow each item to grow to fill available space */
        flex-shrink: 1; /* Allow each item to shrink if needed */
        display: flex; /* Make the list items flex containers */
        justify-content: center; /* Center the content horizontally */
        align-items: center; /* Center the content vertically */
        max-height: 100%; /* Ensure items do not exceed the pill's height */
    }

    /* Adjust the size of the content (icons, text, etc.) inside the list items */
    #color-counters li > *, #category-counters li > * {
        max-height: 50%; /* Ensure content does not exceed the list item's height */
        max-width: 50%; /* Ensure content does not exceed the list item's width */
        font-size: 2.5vw; /* Responsive font size for the content */
    }
}


/* Media query for tablet devices */
@media (min-width: 768px) and (max-width: 1024px) {
    #map {
        left: 15px; /* Consistent margin from the left */
        right: calc(40% + 0px); /* Adjusting for sidebar width and right margin */
        top: 15px; /* Consistent margin from the top */
        bottom: 15px; /* Consistent margin from the bottom */
        border-radius: 30px; /* Maintain border radius */
    }
	
	

    #sidebar {
        width: calc(40% - 30px); /* Sidebar takes up 40% width minus the total horizontal margins */
        right: 15px; /* Consistent margin from the right */
        top: 15px; /* Consistent margin from the top */
        bottom: 15px; /* Consistent margin from the bottom */
        padding: 10px; /* Maintain padding */
        border-radius: 30px; /* Maintain border radius */
    }
	
}
 </style>
<body>
<div class="color-111111" id="sidebar-mobileheader" style="display: none; background-color: #111111;">
<img class="logo-img appear-on-mobile" src="static/logo_long.png" style="display: none; max-width: 97%; height: auto; display: block; margin-bottom: 0px; border-radius: 0px;"/>
<h3 class="appear-on-mobiledisabled resistant-h3" style="display: none; color: white; text-align: center; margin-top: 5px;">
    Wie stehen Sie zu den Orten in Ihrer Gemeinde?
   </h3>
<h3 class="appear-on-mobiledisabled resistant-h3" style="display: none; color: white; text-align: center; margin-top: -12px; margin-bottom: 7px">
    Lassen Sie es uns auf dieser Karte wissen!
   </h3>
</div>
<div id="map">
<!-- Inside the map div -->
<div id="counter-pill">
<ul id="color-counters" style="list-style: none; display: flex; padding: 0; margin: 0;">
<!-- Color circles will be inserted here -->
</ul>
<ul id="category-counters" style="list-style: none; display: flex; padding: 0; margin: 0;">
<!-- Category symbols will be inserted here -->
</ul>
</div>
</div>
<?php MAP END ?>
<?php SIDEBAR BODY START ?>
<div class="color-111111" id="sidebar" style="background-color: #111111;">
<?php LOGO START ?>
<img class="logo-img hide-on-mobile" src="static/logo_long.png" style="max-width: 97%; height: auto; display: block; margin-bottom: 7px; border-radius: 0px;"/>
<?php LOGO END ?>
<?php WEBSITE DESCRIPTION START ?>
<h3 class="hide-on-mobile resistant-h3" style="color: white; text-align: center; margin-top: 5px;">
    Wie stehen Sie zu den Orten in Ihrer Gemeinde?
   </h3>
<h3 class="hide-on-mobile resistant-h3" style="color: white; text-align: center; margin-top: -12px; margin-bottom: 7px">
    Lassen Sie es uns auf dieser Karte wissen!
   </h3>
<?php WEBSITE DESCRIPTION END ?>
<!-- Popup HTML Structure -->


<!-- SMALL OPTIONS MENU TOP START -->
<div class="smalloptionsmenutop" style="display: flex; align-items: center; justify-content: center;">
<div class="left-container">
<!-- This button shows the user a list of existing pins -->
<div class="pinlist-div" id="pinlistdiv" onclick="toggleSearchFilter()" style="border-radius: 30px;">
<img src="static/pinlisticon.png"/>
</div>
<!-- This button shows the user a list of existing pins -->
<div class="info-div" id="infoDiv" style="border-radius: 30px;">
<img src="static/infoicon.png"/>
</div>
</div>
<div class="button-s color-3a3a3a" id="buttonS" onclick="addAndRemoveClass()" style="background-color: #3a3a3a; width: auto; height: auto; padding: 15px;">
<h3>
      Wie funktioniert's?
     </h3>
</div>
<div class="right-container">
<div class="lightswitch-div" id="lightswitchDiv" style="border-radius: 30px;">
<img src="static/sunicon.png"/>
</div>
<div class="key-div" id="keyDiv" style="border-radius: 30px;">
<img src="static/keyicon.png"/>
</div>
</div>
</div>
<!-- SMALL OPTIONS MENU TOP END -->
<!-- Search and Filter Section -->
<div id="search-filter-section" style="display: none; max-height: 350px; overflow-y: auto; max-width: 97%; margin-left:auto; margin-bottom: 0; margin-top: 3px; margin-right: auto;">
<div class="filter-container">
<input id="search-box" style="border-radius: 30px; padding: 5px; border: 1.5px solid black;" oninput="filterObjects()" placeholder="Search by note..." type="text"/>
<select id="color-filter" style="border-radius: 30px; padding: 5px; border: 1.5px solid black;" onchange="filterObjects()">
<option style="border-radius: 30px; padding: 5px;"value="">
      Filter by color
     </option>
<!-- Dynamically populate color options here -->
</select>
<select id="type-filter" style="border-radius: 30px; padding: 5px; margin-bottom: 7.5px; border: 1.5px solid black;"onchange="filterObjects()">
<option value="">
      Filter by object type
     </option>
<option value="rectangle">
      Rectangle
     </option>
<option value="circle">
      Circle
     </option>
<option value="marker">
      Marker
     </option>
<option value="polygon">
      Polygon
     </option>
<!-- Add more object types as needed -->
</select>
</div>

<!-- Object List Section -->
<div id="object-list">
<!-- Dynamically populated object list will go here -->
</div>
</div>
<?php CITY LOGO START ?>
<img class="hide-on-mobile resistant-image" id="overlay-image" src="static/overlay.jpg" style="max-width: 97%; height: auto; display: block; margin-left:auto; margin-right:auto; margin-top: 3px; margin-bottom: 0px; border-radius: 30px; max-height: 368px;"/>
<?php CITY LOGO END ?>
<div id="tool-selection-popup" style="display: none;">
  <button id="marker-btn" class="tool-btn selected" onclick="selectTool('.leaflet-draw-draw-marker', this)">
    <img src="/static/popupmenu_marker_darkmode.png" alt="Marker">
  </button>
  <button id="rectangle-btn" class="tool-btn" onclick="selectTool('.leaflet-draw-draw-rectangle', this)">
    <img src="/static/popupmenu_rectangle_darkmode.png" alt="Rectangle">
  </button>
  <button id="circle-btn" class="tool-btn" onclick="selectTool('.leaflet-draw-draw-circle', this)">
    <img src="/static/popupmenu_circle_darkmode.png" alt="Circle">
  </button>
  <button id="polygon-btn" class="tool-btn" onclick="selectTool('.leaflet-draw-draw-polygon', this)">
    <img src="/static/popupmenu_polygon_darkmode.png" alt="Polygon">
  </button>
</div>


<svg width="0" height="0" id="hatch-patterns">
    <defs>
        <pattern id="diagonalHatch" width="4" height="4" patternTransform="rotate(45 0 0)" patternUnits="userSpaceOnUse">
            <path d="M-1,1 l2,-2
                     M0,4 l4,-4
                     M3,5 l2,-2" stroke="gray" stroke-width="1"/>
        </pattern>
    </defs>
</svg>

<?php ADMIN TOOLS (OTP PROTECTED) START // Categories here are dynamically generated from the "static/categories.html" file. Additional categories can be added or removed by editing "static/categories.html".?>
<div class="menu-admintools" id="dynamicgeneration-admintools">
</div>
<?php ADMIN TOOLS (OTP PROTECTED) END // Categories here are dynamically generated from the "static/categories.html" file. Additional categories can be added or removed by editing "static/categories.html".?>
<?php CATEGORIES PULL START ?>
<div class="container">
    <div id="tool-selection-popup">
        <!-- Popup content -->
    </div>

    <iframe id="categories-iframe" frameborder="0" src="/categories" style="width:100%; height:100%; border:none;"></iframe>
</div>
<?php CATEGORIES PULL END ?>
</div>
<?php SIDEBAR BODY END ?>


<script>
// Initialize the map
var map = L.map('map').setView([48.4102, 15.6022], 15);
var currentDrawnLayer = null;

// Calculate the offset for boundaries
var horizontalOffset = 1125; // 1.125 km on each side, total 2.25 km
var verticalOffset = 594; // 0.59375 km on each side, total 1.1875 km

// Define the boundaries
var centerPoint = map.project([48.4102, 15.6022], map.getZoom());
var southWest = map.unproject(centerPoint.subtract([horizontalOffset, verticalOffset]), map.getZoom());
var northEast = map.unproject(centerPoint.add([horizontalOffset, verticalOffset]), map.getZoom());
var bounds = L.latLngBounds(southWest, northEast);


// Calculate extended bounds for 10 km buffer
var extendedHorizontalOffset = horizontalOffset + 1000; // Add 10 km
var extendedVerticalOffset = verticalOffset + 1000; // Add 10 km
var extendedSouthWest = map.unproject(centerPoint.subtract([extendedHorizontalOffset, extendedVerticalOffset]), map.getZoom());
var extendedNorthEast = map.unproject(centerPoint.add([extendedHorizontalOffset, extendedVerticalOffset]), map.getZoom());
var extendedBounds = L.latLngBounds(extendedSouthWest, extendedNorthEast);

// Set the max bounds to restrict dragging beyond 10 km from the original boundary
map.setMaxBounds(extendedBounds);

// Debugging: Log when the user reaches the edge of the draggable area
map.on('drag', function() {
    if (!extendedBounds.contains(map.getCenter())) {
        console.log("Reached the edge of the draggable area");
    }
});

// Define the coordinates for a very large outer rectangle
var outerBounds = [
    L.latLng(-90, -180),
    L.latLng(90, -180),
    L.latLng(90, 180),
    L.latLng(-90, 180),
    L.latLng(-90, -180)
];
        console.log("Boundaries defined:", bounds);


// Define the coordinates for the inner rectangle (the boundary)
var innerBounds = [
    bounds.getSouthWest(),
    bounds.getNorthWest(),
    bounds.getNorthEast(),
    bounds.getSouthEast(),
    bounds.getSouthWest()
];

// Create a polygon with a hole (inverted polygon)
var invertedPolygon = L.polygon([outerBounds, innerBounds], {color: 'grey', fillColor: 'grey', fillOpacity: 0.5}).addTo(map);

// Draw the boundary rectangle
L.rectangle(bounds, {color: "#808080", weight: 2, fill: false}).addTo(map);
        console.log("Boundary rectangle drawn");

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            minZoom: 15,
            attribution: '| Stimmungskompass | © OpenStreetMap contributors'
        }).addTo(map);
		
		// Map layers
var osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    minZoom: 15,
    attribution: '....'
});

var satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    minZoom: 15,
    attribution: '&copy; Esri &mdash; Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, GIS User Community'
});

var thunderforestLayers = {
    "Atlas": L.tileLayer('https://tile.thunderforest.com/atlas/{z}/{x}/{y}.png?apikey=5c57f95ca93348f1a37f6572742a5b48', {
        minZoom: 15,
        attribution: 'Tiles © Thunderforest, ....'
    }),
    "Neighbourhood": L.tileLayer('https://tile.thunderforest.com/neighbourhood/{z}/{x}/{y}.png?apikey=5c57f95ca93348f1a37f6572742a5b48', {
        minZoom: 15,
        attribution: 'Tiles © Thunderforest, ....'
    }),
    "Transport": L.tileLayer('https://tile.thunderforest.com/transport/{z}/{x}/{y}.png?apikey=5c57f95ca93348f1a37f6572742a5b48', {
        minZoom: 15,
        attribution: 'Tiles © Thunderforest, ....'
    }),
    "Cycle": L.tileLayer('https://tile.thunderforest.com/cycle/{z}/{x}/{y}.png?apikey=5c57f95ca93348f1a37f6572742a5b48', {
        minZoom: 15,
        attribution: 'Tiles © Thunderforest, ....'
    }),
    "Mobile_Atlas": L.tileLayer('https://tile.thunderforest.com/mobile-atlas/{z}/{x}/{y}.png?apikey=5c57f95ca93348f1a37f6572742a5b48', {
        minZoom: 15,
        attribution: 'Tiles © Thunderforest, ....'
    }),
    "Pioneer": L.tileLayer('https://tile.thunderforest.com/pioneer/{z}/{x}/{y}.png?apikey=5c57f95ca93348f1a37f6572742a5b48', {
        minZoom: 15,
        attribution: 'Tiles © Thunderforest, ....'
    }),
};

var baseLayers = {
    "Standardkarte": osmLayer,
    "Satellit": satelliteLayer,
    "Klar 1": thunderforestLayers.Atlas,
    "Klar 2": thunderforestLayers.Neighbourhood,
    "Öffi": thunderforestLayers.Transport,
    "Radwege": thunderforestLayers.Cycle,
    "Atlas": thunderforestLayers.Mobile_Atlas,
    "Papyrus": thunderforestLayers.Pioneer,
};


        // Add default layer to map
        baseLayers["Standardkarte"].addTo(map);


function createIcon(pinSize, outlineSize) {
    var svgIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="${pinSize}" height="${pinSize}" viewBox="0 0 ${pinSize} ${pinSize}">
        <circle cx="${pinSize / 2}" cy="${pinSize / 2}" r="${pinSize / 4}" />
        <circle cx="${pinSize / 2}" cy="${pinSize / 2}" r="${pinSize / 4}" stroke-width="${outlineSize}" fill="none" stroke-opacity="0.5" />
    </svg>`;

    console.log("SVG Icon:", svgIcon); // Debugging statement


    return L.icon({
        iconUrl: `data:image/svg+xml;base64,${btoa(svgIcon)}`,
        iconSize: [pinSize, pinSize],
        iconAnchor: [pinSize / 2, pinSize / 2],
        popupAnchor: [0, -pinSize / 2]
    });
}


// Define a custom marker icon
var customMarkerIcon = L.divIcon({
    className: 'custom-marker-icon',
    html: '<div style="width: 24px; height: 24px; border-radius: 50%; background-color: YOUR_CATEGORY_COLOR;"></div>',
    iconSize: [24, 24],
    iconAnchor: [12, 12] // Centers the icon
});


// Global variable for the custom cursor icon
var customCursorIcon;

// Create and attach a custom cursor icon
function createCustomCursorIcon(color) {
    removeCustomCursorIcon();  // Ensure any existing custom cursor is removed
    customCursorIcon = L.DomUtil.create('div', 'custom-cursor-icon');
    customCursorIcon.innerHTML = '<div style="width: 24px; height: 24px; border-radius: 50%; background-color: ' + color + ';"></div>';
    customCursorIcon.style.position = 'absolute';
    customCursorIcon.style.pointerEvents = 'none';
    customCursorIcon.style.zIndex = '1000'; // Set high z-index
    document.body.appendChild(customCursorIcon);
}



// Function to update the position of the custom cursor icon
function updateCustomCursorIconPosition(e) {
    var mapDiv = map.getContainer(); // Get the map container
    var mapRect = mapDiv.getBoundingClientRect();

    // Check if the cursor is inside the map div
    if (e.clientX >= mapRect.left && e.clientX <= mapRect.right && e.clientY >= mapRect.top && e.clientY <= mapRect.bottom) {
        customCursorIcon.style.display = 'block'; // Show the cursor icon
        customCursorIcon.style.left = e.clientX + 'px';
        customCursorIcon.style.top = e.clientY + 'px';
    } else {
        customCursorIcon.style.display = 'none'; // Hide the cursor icon outside the map
    }
}



// Remove the custom cursor icon
function removeCustomCursorIcon() {
    if (customCursorIcon) {
        document.body.removeChild(customCursorIcon);
        customCursorIcon = null;
    }
}

// Layers control
L.control.layers(baseLayers).addTo(map);

// Feature group for drawn items
// Feature group for drawn items
// Feature group for drawn items
var drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);

// Initialize the draw control with default options
var drawControl = new L.Control.Draw({
    edit: {
        featureGroup: drawnItems
    },
    draw: {
        marker: {
            icon: customMarkerIcon // Use custom icon for marker
        },
        polyline: {
            shapeOptions: {
                color: currentCategory, // Default color
                weight: 4
            }
        },
        rectangle: {
            shapeOptions: {
                color: currentCategory, // Default color
                weight: 4
            }
        },
        circle: {
            shapeOptions: {
                color: currentCategory, // Default color
                weight: 4
            }
        },
        polygon: {
            shapeOptions: {
                color: currentCategory, // Default color
                weight: 4
            }
        },
    }
});

// Add the draw control to the map
map.addControl(drawControl);

// Function to update the draw handlers' options based on the current category
function updateDrawHandlers() {
    var options = {
        color: currentCategory, // Dynamic color
        weight: 4
    };

    // Check and update options for each handler
    if (drawControl._toolbars.draw && drawControl._toolbars.draw._modes) {
        if (drawControl._toolbars.draw._modes.rectangle) {
            drawControl._toolbars.draw._modes.rectangle.handler.options.shapeOptions = options;
        }
        if (drawControl._toolbars.draw._modes.circle) {
            drawControl._toolbars.draw._modes.circle.handler.options.shapeOptions = options;
        }
        if (drawControl._toolbars.draw._modes.polygon) {
            drawControl._toolbars.draw._modes.polygon.handler.options.shapeOptions = options;
        }
        if (drawControl._toolbars.draw._modes.polyline) {
            drawControl._toolbars.draw._modes.polyline.handler.options.shapeOptions = options;
        }
    }
}

// Event listener for shape creation end
map.on(L.Draw.Event.CREATED, function(event) {
    console.log('Shape created:', event.layerType);
    var layer = event.layer;
    drawnItems.addLayer(layer); // Add to feature group
});




// Function to set cursor style for map and its child elements
function setCursorStyleForMap(cursorStyle) {
    var mapContainer = map.getContainer();
    mapContainer.style.cursor = cursorStyle;

    // Apply cursor style to current child elements
    Array.from(mapContainer.getElementsByTagName('*')).forEach(function(element) {
        element.style.cursor = cursorStyle;
    });

    // Use a MutationObserver to apply the style to new elements added to the map
    var observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.addedNodes.length) {
                mutation.addedNodes.forEach(function(node) {
                    if (node.nodeType === 1) { // Element node
                        node.style.cursor = cursorStyle;
                        Array.from(node.getElementsByTagName('*')).forEach(function(child) {
                            child.style.cursor = cursorStyle;
                        });
                    }
                });
            }
        });
    });

    // Start observing the map container for added nodes
    observer.observe(mapContainer, { childList: true, subtree: true });

    // Store the observer in a global variable to disconnect it later
    window.mapCursorObserver = observer;
}

// Function to reset cursor style and stop observing for changes
function resetCursorStyleForMap() {
    if (window.mapCursorObserver) {
        window.mapCursorObserver.disconnect(); // Disconnect the observer
        delete window.mapCursorObserver;
    }

    var mapContainer = map.getContainer();
    mapContainer.style.cursor = ''; // Reset cursor style

    // Reset cursor style for child elements
    Array.from(mapContainer.getElementsByTagName('*')).forEach(function(element) {
        element.style.cursor = '';
    });
}

// Flag to track if warning has already been shown
var warningShown = false;

// Function to show warning message
function showWarningMessage(message) {
    if (!warningShown) {
        console.log('Warning:', message);
        alert(message);
        warningShown = true; // Set the flag to true after showing the warning
    }
}

// Function to reset the warning flag
function resetWarningFlag() {
    warningShown = false; // Reset the flag when drawing is stopped or started
}

// Function to check if a category is selected
function isCategorySelected() {
    return currentCategory && currentCategory !== '';
}

let popupTimer;

function showToolSelectionPopup() {
  fetch('/get-allowed-object-types')
  .then(response => response.json())
  .then(data => {
    const popup = document.getElementById('tool-selection-popup');
    if (popup) {
      document.getElementById('marker-btn').style.display = data.marker ? 'inline-block' : 'none';
      document.getElementById('rectangle-btn').style.display = data.rectangle ? 'inline-block' : 'none';
      document.getElementById('circle-btn').style.display = data.circle ? 'inline-block' : 'none';
      document.getElementById('polygon-btn').style.display = data.polygon ? 'inline-block' : 'none';

      popup.style.display = 'flex'; // Apply flex display
      popup.style.flexDirection = 'row'; // Ensure horizontal layout
      resetToolSelectionPopupTimer();
    }
  })
  .catch(error => {
    console.error('Error fetching allowed object types:', error);
    // Handle error or set default behavior
  });
}


function resetToolSelectionPopupTimer() {
  clearTimeout(popupTimer);
  popupTimer = setTimeout(function() {
    const popup = document.getElementById('tool-selection-popup');
    if (popup) {
      popup.style.display = 'none';
    }
  }, 10000); // Hide after 10 seconds
}

function selectTool(selector, button) {
  // Reset all buttons to unselected state
  document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('selected'));

  // Mark the clicked button as selected
  button.classList.add('selected');

  // Find and click the corresponding Leaflet tool button
  var toolButton = document.querySelector(selector);
  if (toolButton) {
    toolButton.click();
    console.log(`Tool ${selector} activated programmatically`);
  } else {
    console.log(`Tool button for ${selector} not found`);
  }

  // Reset popup timer on each click
  resetToolSelectionPopupTimer();
}

// Add click event listener to popup to reset timer on click
document.getElementById('tool-selection-popup').addEventListener('click', resetToolSelectionPopupTimer);

// Call showToolSelectionPopup when category is set
function setCategory(category) {
    currentCategory = category;
    console.log('Category set to:', currentCategory);
    updateDrawHandlers(); // Update draw handlers when category changes
    console.log('setCategory called with category:', category);

    // Display the tool selection popup
    var popup = document.getElementById('tool-selection-popup');
    if (popup) {
        popup.style.display = 'block';
        console.log('Popup displayed');
    } else {
        console.log('Popup element not found');
    }

    // Default to Marker tool
    selectTool('.leaflet-draw-draw-marker');
	    showToolSelectionPopup();

}

function selectTool(selector) {
    var toolButton = document.querySelector(selector);
    if (toolButton) {
        console.log(`Tool button for ${selector} found:`, toolButton);
        toolButton.click(); // Simulate a click on the tool button
        console.log(`Tool ${selector} activated programmatically`);
    } else {
        console.log(`Tool button for ${selector} not found`);
    }
}

// Function to programmatically activate the marker tool
function activateMarkerTool() {
    var markerToolButton = document.querySelector('.leaflet-draw-draw-marker');
    if (markerToolButton) {
        markerToolButton.click(); // Simulate a click on the marker tool
        console.log('Marker tool activated programmatically');
    }
}

var currentCategory = ''; // Start with no category selected

// Event listener for when the draw tool is selected
// Update event listener for when the draw tool is selected
map.on(L.Draw.Event.TOOLBAROPENED, function() {
    console.log('Draw toolbar opened');
    resetWarningFlag(); // Reset the warning flag
    if (!isCategorySelected()) {
        showWarningMessage('Select a category first');
    }
});

// Global variables to track drawing state and the current layer
var isDrawing = false;
var currentLayer = null;

// Event listener for when the marker tool is selected
map.on(L.Draw.Event.DRAWSTART, function(event) {
    console.log('Draw start:', event.layerType);
	  isDrawing = true; // Set the flag to indicate that drawing has started
    currentLayer = null; // Reset the current layer
    resetWarningFlag(); // Reset the warning flag
    if (!isCategorySelected()) {
        showWarningMessage('Select a category first');
        if (drawControl._toolbars.draw._activeMode) {
            drawControl._toolbars.draw._activeMode.handler.disable();
        }
        return;
    }


    if (event.layerType === 'marker') {
        createCustomCursorIcon(currentCategory);
        document.addEventListener('mousemove', updateCustomCursorIconPosition);
        setCursorStyleForMap('none');
    }
});

// Update event listener for when drawing is stopped
map.on(L.Draw.Event.DRAWSTOP, function(event) {
    console.log('Draw stop:', event.layerType);
	  if (currentLayer) {
        var type = currentLayer.getLayerType ? currentLayer.getLayerType() : '';
        var isWithinBounds = type === 'marker' ? bounds.contains(currentLayer.getLatLng()) : bounds.contains(currentLayer.getBounds());

        if (!isWithinBounds) {
            map.removeLayer(currentLayer); // Remove the layer if it's outside the boundaries
        } else {
            drawnItems.addLayer(currentLayer); // Add the layer if it's within the boundaries
        }
    }
    isDrawing = false; // Reset the drawing flag
	    currentLayer = null; // Reset the current layer

    resetWarningFlag(); // Reset the warning flag
    if (event.layerType === 'marker') {
        removeCustomCursorIcon();
        document.removeEventListener('mousemove', updateCustomCursorIconPosition);
        resetCursorStyleForMap();
    }
});





// Function to create a colored circle icon
function createColoredCircleIcon(color) {
var svgIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">
    <circle cx="16" cy="16" r="8" fill="${color}" />
    <circle cx="16" cy="16" r="8" stroke="${color}" stroke-width="16" fill="none" stroke-opacity="0.5" />
</svg>`;

return L.icon({
    iconUrl: `data:image/svg+xml;base64,${btoa(svgIcon)}`,
    iconSize: [32, 32],
    iconAnchor: [16, 16],
    popupAnchor: [0, -16]
});



}


var postButtonClicked = false;
var currentLayer;

map.on(L.Draw.Event.CREATED, function(event) {
    console.log('Shape creation event triggered'); // Debug: Confirm the event is firing
    console.log('Created shape type:', event.layerType); // Debug: Log the actual type of created shape

    var layer = event.layer;
    var type = event.layerType.toLowerCase();
    var color = currentCategory;
    var shapeType = type;
    currentLayer = layer; // Store the current layer
    isDrawing = false; // Reset the drawing flag as the shape has been created

    // Boundary check
    if (type === 'marker') {
        if (!bounds.contains(layer.getLatLng())) {
            alert("It is not allowed to place objects outside of boundaries!");
            // No need to set isDrawing = false here as the drawing process is already completed
            return; // Exit the function without adding the layer
        }
    } else {
        if (!bounds.contains(layer.getBounds())) {
            alert("It is not allowed to place objects outside of boundaries!");
            // No need to set isDrawing = false here as the drawing process is already completed
            return; // Exit the function without adding the layer
        }
    }
	
	 currentLayer = layer; // Store the current layer
    drawnItems.addLayer(layer); // Add to feature group
    isDrawing = false; // Reset the drawing flag as shape creation is complete
	
    if (type === 'marker') {
        var customIcon = createColoredCircleIcon(color);
        layer.setIcon(customIcon);
    } else if (type === 'rectangle') {
        console.log('Applying hatching pattern...'); // Debug: Log when applying the pattern
        layer.setStyle({
            color: '#FF7043',
            fillPattern: document.getElementById('diagonalHatch')
        });
    } else {
        layer.setStyle({ color: color });
    }

    drawnItems.addLayer(layer);

	let badWords = [];


// Fetch the list of bad words from filter.json
fetch('/static/filter.json')
    .then(response => response.json())
    .then(data => {
        // Merge the arrays of bad words from different languages into one array
        badWords = [].concat(...Object.values(data));
    });

 
    drawnItems.addLayer(layer);
    var shapeData = layer.toGeoJSON();
    var radius = (type === 'circle' || type === 'circlemarker') ? layer.getRadius() : null;

    if (!shapeLayersByColor[color]) {
        shapeLayersByColor[color] = [];
    }
    if (!shapeLayersByType[shapeType]) {
        shapeLayersByType[shapeType] = [];
    }
    shapeLayersByColor[color].push(layer);
    shapeLayersByType[shapeType].push(layer);
    console.log('Added layer to shapeLayersByColor and shapeLayersByType', layer);

    var popupContent = '<form id="note-form">' +
                       '<textarea id="shape-note" placeholder="Enter your note here"></textarea><br>' +
                       '<button type="button" id="save-note">Post</button>' +
                       '<button type="button" id="cancel-note">Cancel</button>' +
                       '</form>';

    layer.bindPopup(popupContent, {
        keepInView: true,
        closeButton: false
    });
	
 // Delay opening the popup to ensure it is rendered
    setTimeout(function() {
        layer.openPopup();
    }, 10);

     layer.on('popupopen', function() {
        setTimeout(function() {
            var saveButton = document.getElementById('save-note');
            var cancelButton = document.getElementById('cancel-note');

            saveButton.addEventListener('click', function() {
                var noteText = document.getElementById('shape-note').value;

                // Create a RegExp pattern from the list of bad words
                const badWordPattern = new RegExp(`${badWords.join('|')}`, 'i');
                const hasBadWord = badWordPattern.test(noteText);

                if (hasBadWord) {
                    alert("Beleidigende Worte sind nicht erlaubt.");
                    return;
                }

                // Pattern to detect repeated letters (same letter repeating more than 4 times)
                const repeatedLetterPattern = /(.)\1{4,}/;
                const hasRepeatedLetters = repeatedLetterPattern.test(noteText);

                if (hasRepeatedLetters) {
                    alert("Wiederholte Buchstaben sind nicht erlaubt.");
                    return;
                }

                // Pattern to detect links (http, https, www, or domain names)
                const linkPattern = /(http:\/\/|https:\/\/|www\.|\.(com|net|org|info|io|at|de|uk|co|gov|edu|eu|biz|tv|me|us|ca|au|nz))/i;
                const hasLink = linkPattern.test(noteText);

                if (hasLink) {
                    alert("Links sind nicht erlaubt.");
                    return;
                }

                if (noteText.length >= 10 && noteText.length <= 150) {
                    // Your existing logic to save shape with data
                    saveShapeWithData(shapeData, shapeType, radius, noteText, layer);
                } else {
                    alert("Bitte geben Sie zwischen 10 und 150 Zeichen ein.");
                }

                layer.closePopup();
            });

            cancelButton.addEventListener('click', function() {
                console.log('Cancel button clicked. Canceling shape creation.');
                layer.closePopup();
                drawnItems.removeLayer(layer);
            });
        }, 10);
     }
	 );
    // Setup click event listener on the document to detect clicks outside the popup
    document.addEventListener('click', function onClickOutsidePopup(event) {
        if (!layer._popup._container.contains(event.target) && !postButtonClicked) {
            console.log('Click detected outside the popup. Canceling shape creation.');
            drawnItems.removeLayer(layer);
            document.removeEventListener('click', onClickOutsidePopup); // Remove the event listener
        }
    });
}
);
function bindPopupWithNote(layer, note) {
    var popupContent = '<div><strong></strong> ' + note + '</div>';
    layer.bindPopup(popupContent, {
        keepInView: true
    });
}

function saveShapeWithData(shapeData, shapeType, radius, note, layer) {
    $.ajax({
        url: '/api/shapes',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            shape_data: shapeData,
            shape_type: shapeType,
            shape_color: currentCategory,
            radius: radius,
            shape_note: note
        }),
        success: function(response) {
            console.log('Shape saved with ID:', response.id);
            layer.options.id = response.id;
            bindPopupWithNote(layer, note);
            drawnItems.addLayer(layer);
            console.log('Shape and note saved to the database.');
        },
        error: function(xhr, status, error) {
            console.error('Error saving shape:', error);
        }
    });
}
// Load shapes from server


// This function will handle the deletion of shapes
// Function to handle individual shape deletion
function handleDelete(layer) {
    var shapeId;
    // Check for the id in various possible locations within the layer object
    if (layer.options && layer.options.id) {
        shapeId = layer.options.id;
    } else if (layer.feature && layer.feature.properties && layer.feature.properties.id) {
        shapeId = layer.feature.properties.id;
    } else if (layer._layers) {
        // If the layer is a FeatureGroup, check each sub-layer for an id
        var subLayers = Object.values(layer._layers);
        if (subLayers.length > 0 && subLayers[0].feature && subLayers[0].feature.properties) {
            shapeId = subLayers[0].feature.properties.id;
        }
    }
    
    if (shapeId) {
        console.log('Deleting shape with ID:', shapeId);
        $.ajax({
            url: '/api/shapes/' + shapeId,
            type: 'DELETE',
            success: function(response) {
                console.log('Shape deleted with ID:', shapeId);
            },
            error: function(xhr, status, error) {
                console.error('Error deleting shape with ID:', shapeId, error);
            }
        });
        map.removeLayer(layer);
    } else {
        console.error('Error: shape ID is undefined, cannot delete. Layer:', layer);
        // Additional logging to debug the layer's structure
        console.log('Layer details:', layer);
        if (layer._layers) {
            console.log('Nested layers:', Object.values(layer._layers));
        }
    }
}
 
// Function to load shapes from the server
function loadShapes() {
    console.log('Loading shapes...');
    $.get('/api/shapes', function(response) {
        console.log('Shapes loaded:', response.shapes.length);
        response.shapes.forEach(function(shape) {
            var shapeLayer;
            var center, radius, popupContent;
            var shapeType = shape.shape_type.toLowerCase();

            if (shapeType === 'marker') {
                center = L.GeoJSON.coordsToLatLng(shape.shape_data.geometry.coordinates);
                // Create a custom icon with the shape color
                var customIcon = createColoredCircleIcon(shape.shape_color);
                shapeLayer = L.marker(center, { icon: customIcon });
            } else if (shapeType === 'circle' || shapeType === 'circlemarker') {
                center = L.GeoJSON.coordsToLatLng(shape.shape_data.geometry.coordinates);
                radius = shape.radius;
                shapeLayer = L.circle(center, { color: shape.shape_color, radius: radius });
            } else {
                shapeLayer = L.geoJSON(shape.shape_data, {
                    style: function() { return { color: shape.shape_color }; }
                });
            }

            // Attach the ID to the layer
            shapeLayer.options.id = shape.id;

            // Bind popup and click event if a note is present
            if (shape.shape_note) {
                popupContent = '<div><strong></strong> ' + shape.shape_note + '</div>';
                shapeLayer.bindPopup(popupContent, {
                    keepInView: true
                });
            }

            // Add the layer to the map
            drawnItems.addLayer(shapeLayer);
            console.log('Shape added to map:', shapeLayer);
        });
    }).fail(function(jqXHR, textStatus, errorThrown) {
        console.error('Failed to load shapes:', textStatus, errorThrown);
    });
}





map.on(L.Draw.Event.DELETED, function(event) {
    var layers = event.layers;
    layers.eachLayer(function(layer) {
        console.log('Preparing to delete layer:', layer);
        handleDelete(layer);
    });
});

map.on('draw:deletestop', function(event) {
    if (event.target._deletedLayers) {
        event.target._deletedLayers.eachLayer(function(layer) {
            console.log('Clearing layer:', layer);
            handleDelete(layer);
        });
    }
});


loadShapes();

  </script>

  
<?php DARK AND LIGHT MODE SWITCH START ?>
 <script>
        // Dark and light mode switcher
        console.log("Dark and light mode switcher successfully loaded.");
        let isLightMode = false;  // Initialize with dark mode

        let objectsData = []; // Global variable to store objects data

        // Fetch and display all objects and populate filters when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            fetch('/api/all-shapes').then(response => response.json()).then(data => {
                console.log('Objects loaded from the database:', data.shapes);
                objectsData = data.shapes; // Store data globally
                displayObjects(objectsData);
                populateColorFilter(objectsData);
            });
        });

        // Ensure the dark mode is set on initial load
        document.documentElement.classList.add('dark-mode');
        document.documentElement.style.setProperty('--popup-bg-color', '#111111');
        document.documentElement.style.setProperty('--popup-text-color', 'white');
        document.documentElement.style.setProperty('--leaflet-control-layers-expanded-bg', '#111111');
        document.documentElement.style.setProperty('--leaflet-control-layers-expanded-text', 'white');
        document.documentElement.style.setProperty('--leaflet-control-layers-selector-text', 'white');
        document.documentElement.style.setProperty('--leaflet-control-layers-list-text', 'white');
        document.documentElement.style.setProperty('--leaflet-control-layers-before-bg', 'url("static/mapicon2.png")');
        document.documentElement.style.setProperty('--leaflet-disabled-bg', '#111111');
        document.documentElement.style.setProperty('--leaflet-disabled-color', 'white');
        document.documentElement.style.setProperty('--note-text-color', 'white'); // Default to white for dark mode

        // Function to switch between light and dark mode
        function toggleLightMode() {
            // Toggle the mode first before applying the classes
            isLightMode = !isLightMode;
            document.documentElement.classList.toggle('dark-mode', !isLightMode);
            document.documentElement.classList.toggle('light-mode', isLightMode);

            // Update color variables for popup based on the mode
            if (isLightMode) {
                document.documentElement.style.setProperty('--popup-bg-color', '#ffffff');
                document.documentElement.style.setProperty('--counter-pill-bg-color', '#f3f4f8');
                document.documentElement.style.setProperty('--counter-pill-text-color', 'black');
                document.documentElement.style.setProperty('--leaflet-control-bg-dark', '#f3f4f8');
                document.documentElement.style.setProperty('--leaflet-control-color-dark', 'black');
                document.documentElement.style.setProperty('--leaflet-control-layers-list-text', 'black');
                document.documentElement.style.setProperty('--leaflet-control-layers-before-bg', 'url("static/mapicon2b.png")');
                document.documentElement.style.setProperty('--leaflet-disabled-bg', '#d4d7da');
                document.documentElement.style.setProperty('--leaflet-disabled-color', 'black');
                document.documentElement.style.setProperty('--note-text-color', 'black');
                document.documentElement.style.setProperty('--counter-color-border', '2px solid #111111');
                document.documentElement.style.setProperty('--popup-text-color', 'black');
                document.documentElement.style.setProperty('--border-hover-color', '#666666'); // Custom border color for hover in light mode
                document.documentElement.style.setProperty('--border-selected-color', '#444444'); // Custom border color for selected in light mode
                document.documentElement.style.setProperty('--leaflet-control-layers-expanded-bg', '#f3f4f8');
                document.documentElement.style.setProperty('--leaflet-control-layers-expanded-text', 'black');
                document.documentElement.style.setProperty('--leaflet-control-layers-selector-text', 'black');
            } else {
                document.documentElement.style.setProperty('--popup-bg-color', '#111111');
                document.documentElement.style.setProperty('--counter-pill-bg-color', '#111111');
                document.documentElement.style.setProperty('--counter-pill-text-color', 'white');
                document.documentElement.style.setProperty('--leaflet-control-bg-dark', '#3a3a3a');
                document.documentElement.style.setProperty('--leaflet-control-color-dark', 'white');
                document.documentElement.style.setProperty('--leaflet-control-layers-list-text', 'white');
                document.documentElement.style.setProperty('--leaflet-control-layers-before-bg', 'url("static/mapicon2.png")');
                document.documentElement.style.setProperty('--leaflet-disabled-bg', '#111111');
                document.documentElement.style.setProperty('--leaflet-disabled-color', 'white');
                document.documentElement.style.setProperty('--note-text-color', 'white');
                document.documentElement.style.setProperty('--counter-color-border', '2px solid white');
                document.documentElement.style.setProperty('--popup-text-color', 'white');
                document.documentElement.style.setProperty('--border-hover-color', '#cccccc'); // Reset to dark mode colors
                document.documentElement.style.setProperty('--border-selected-color', '#aaaaaa');
                document.documentElement.style.setProperty('--leaflet-control-layers-expanded-bg', '#111111');
                document.documentElement.style.setProperty('--leaflet-control-layers-expanded-text', 'white');
                document.documentElement.style.setProperty('--leaflet-control-layers-selector-text', 'white');
            }

            // Helper function to safely set the src attribute for all elements matching the selector
            function setImgSrc(selector, lightSrc, darkSrc) {
                const elements = document.querySelectorAll(selector);
                elements.forEach(element => {
                    element.src = isLightMode ? lightSrc : darkSrc;
                });
            }

            // Update the image sources based on the mode
            setImgSrc('.logo-img', 'static/logo_long2.png', 'static/logo_long.png');
            setImgSrc('#pinlistdiv img', 'static/pinlisticon2.png', 'static/pinlisticon.png');
            setImgSrc('#infoDiv img', 'static/infoicon2.png', 'static/infoicon.png');
            setImgSrc('#lightswitchDiv img', 'static/sunicon2.png', 'static/sunicon.png');
            setImgSrc('#keyDiv img', 'static/keyicon2.png', 'static/keyicon.png');

            // Update the body's background color
            document.body.style.backgroundColor = isLightMode ? '#f3f4f8' : '#1b1b1b';

            // Update the border property for counter-color class
            const counterColorElements = document.querySelectorAll('.counter-color');
            counterColorElements.forEach(el => {
                el.style.border = isLightMode ? '2px solid #111111' : '2px solid white';
            });

            // Update the sidebar background color
            const sidebar = document.getElementById('sidebar');
            const sidebarMobileHeader = document.getElementById('sidebar-mobileheader');
            if (sidebar) {
                sidebar.style.backgroundColor = isLightMode ? '#D4D7DA' : '#111111';
            }
            if (sidebarMobileHeader) {
                sidebarMobileHeader.style.backgroundColor = isLightMode ? '#D4D7DA' : '#111111';
            }

            // Update the button's background color
            const buttonS = document.getElementById('buttonS');
            if (buttonS) {
                buttonS.style.backgroundColor = isLightMode ? '#111111' : '#3a3a3a';
            }

            // Update the text color for h3 elements with 'resistant-h3' class
            const h3Elements = document.querySelectorAll('.resistant-h3');
            h3Elements.forEach(el => {
                el.style.color = isLightMode ? 'black' : 'white';
            });

            // Update the text color for text elements with 'text-color' class
            const textElements = document.querySelectorAll('.text-color');
            textElements.forEach(el => {
                el.style.color = isLightMode ? 'black' : 'white';
            });

            displayObjects(objectsData);

            console.log("Light mode is now " + (isLightMode ? "enabled" : "disabled") + ".");
        }

        // Add event listener to the light switch div
        document.getElementById('lightswitchDiv').addEventListener('click', toggleLightMode);
    </script>

<script>
   // On website launch, the layout is DARK.
let isDarkMode = true;

function togglePopup() {
    isDarkMode = !isDarkMode;
    document.documentElement.classList.toggle('dark-mode', isDarkMode);
    document.documentElement.classList.toggle('light-mode', !isDarkMode);
}
  </script>
<?php DARK AND LIGHT MODE SWITCH END ?>
<?php BUTTON CLICK AUDIO EFFECTS START ?>
<audio id="buttonClickAudio" preload="auto">
<source src="static/buttonclick.mp3" type="audio/mp3"/>
</audio>
<script>
   document.addEventListener('DOMContentLoaded', function() {
    function playClickSound() {
        // Create a new audio element for each click
        var audio = new Audio('static/buttonclick.mp3');
        // Attempt to play audio without waiting for the promise to resolve
        audio.play().catch(function(e) {
            console.error('Audio play failed:', e);
        });
    }

    // Attach event listener to the static parent element for delegation
    document.addEventListener('click', function(event) {
        // Ensure the clicked element matches the dynamic buttons
        if (event.target.closest('#dynamicgeneration-categorypicker .categorybutton')) {
            playClickSound();
        }
    });
});
  </script>
<script>
   // General click sound effect
document.addEventListener('DOMContentLoaded', function() {
    // Get the audio element
    const audio = document.getElementById('buttonClickAudio');
    
    // Add click event listener to all elements with class 'button-s'
    const buttonSs = document.querySelectorAll('.button-s');
    buttonSs.forEach((button) => {
        button.addEventListener('click', function() {
            audio.play();
        });
    });

    // Add click event listener to all elements with class 'categorybutton'
    const categorybuttons = document.querySelectorAll('.categorybutton');
    categorybuttons.forEach((button) => {
        button.addEventListener('click', function() {
            audio.play();
        });
    });
	
	    // Add click event listener to all elements with class 'button-s'
    const keyDivs = document.querySelectorAll('.key-div');
    keyDivs.forEach((button) => {
        button.addEventListener('click', function() {
            audio.play();
        });
    });
	
	    // Add click event listener to all elements with class 'button-s'
    const pinlistdivs = document.querySelectorAll('.pinlist-div');
    pinlistdivs.forEach((button) => {
        button.addEventListener('click', function() {
            audio.play();
        });
    });
	
		    // Add click event listener to all elements with class 'button-s'
    const lightswitchDivs = document.querySelectorAll('.lightswitch-div');
    lightswitchDivs.forEach((button) => {
        button.addEventListener('click', function() {
            audio.play();
        });
    });
	
		    // Add click event listener to all elements with class 'button-s'
    const infoDivs = document.querySelectorAll('.info-div');
    infoDivs.forEach((button) => {
        button.addEventListener('click', function() {
            audio.play();
        });
    });
	
});
  </script>
<audio id="buttonClickAudio2">
<source src="static/buttonclickSuccess.mp3" type="audio/mp3"/>
</audio>
<audio id="buttonClickAudio3">
<source src="static/buttonclickClose.mp3" type="audio/mp3"/>
</audio>
<script>
   // Popup closing sound effect
document.addEventListener('DOMContentLoaded', function() {
    // Get the audio elements
    const audioSuccess = document.getElementById('buttonClickAudio2');
    const audioClose = document.getElementById('buttonClickAudio3');
    
    // Add event listener to the body element for delegation
    document.body.addEventListener('click', function(event) {
            if (event.target.matches('.leaflet-popup-content button:nth-child(1)')) {
            audioSuccess.play();
        }     else if (event.target.matches('.leaflet-popup-content button:nth-child(2)')) {
            audioClose.play();
        }
    });
});
  </script>
<?php BUTTON CLICK AUDIO EFFECTS END ?>
<?php BOTTOM RIGHT CORNER INFOPOPUP LOGIC START ?>
<script>
   document.addEventListener("DOMContentLoaded", () => {
    const popupTexts = {  
        'Login': {
			title: '<span style="color: #35b7ff;">Admin-Zugriff</span>',
            text: `<form id="loginForm" onsubmit="handleLogin(); return false;">
                <label for="username">Benutzer:</label>
                <input type="text" id="username" name="username"><br><br>

                <label for="password">Passwort:</label>
                <input type="password" id="password" name="password"><br><br>

                <label for="otp">OTP 2FA Token:</label>
                <input type="text" id="otp" name="otp"><br><br>

                <button type="submit" class="button-s" style="padding: 20px; background-color: #35b7ff; border: none; cursor: pointer;">
                    <span style="position: relative; top: 0px;">Anmelden</span>
                </button>
            </form>`,
            color: 'white',
            persist: true
        },
        'uigif-counter': {
            title: 'So funktioniert Filtern:',
            text: '<img src="static/uigif-counter.gif" alt="uigif-counter" style="max-width: 100%; max-height: 800px; width: auto; height: auto;">',
            color: '#f77f00',
            persist: true  // Keep this popup visible forever
        },
		'admin-pindelete': {
        title: 'Einzelne Pins löschen:',
        text: '<img src="static/uigif-deletebyid.gif" alt="uigif-deletebyid" style="max-width: 100%; max-height: 800px; width: auto; height: auto;">',
        color: '#ffffff',
        persist: true  // Keep this popup visible forever
		},
		'admin-pinresize': {
        title: 'Größenänderung:',
        text: '<img src="static/uigif-resize.gif" alt="uigif-resize" style="max-width: 100%; max-height: 800px; width: auto; height: auto;">',
        color: '#ffffff',
        persist: true  // Keep this popup visible forever
		},
        'Overlay': {
            title: '<span style="color: #35b7ff;">Dieses Bild wird ersetzt:</span>',
            text: '<img src="static/overlay.jpg" alt="Overlay Image" style="max-width: 100%; max-height: 400px; width: auto; height: auto; border-radius: 30px;">',
            color: '#ffffff',
            persist: true  // Keep this popup visible forever
        },
        'Success': {
            title: 'Anmeldung erfolgreich!',
            text: 'Wenn Sie Hilfe benötigen, sehen Sie sich die Anleitung an oder wenden Sie sich an den Entwickler.',
            color: 'green',
            persist: false
        },
        'Willkommen auf der Stimmungskarte!': {
            title: 'Willkommen auf der Stimmungskarte!',
            text: 'Diese Karte ist eine bequeme und einfache Möglichkeit, Ihrer Stadt zu zeigen, wie Sie sich darin fühlen.<br><br>Sie können Hinweise an Orten anbringen, die Sie entweder als angenehm oder problematisch empfinden.<br><br><span style="color: #f77f00; font-weight: bold;">Und so funktioniert es:</span><br><span style="color: #f77f00; font-weight: bold;">1.</span> Wählen Sie eine Kategorie.<br><span style="color: #f77f00; font-weight: bold;">2.</span> Platzieren Sie einen Pin auf der Karte.<br><span style="color: #f77f00; font-weight: bold;">3.</span> Teilen Sie uns Ihre Meinung mit!<br><br><span style="font-weight: bold;">Ihre Beiträge sind anonym und können von der Gemeinde zur Verbesserung des öffentlichen Raums genutzt werden.</span> ',
            color: '#f77f00'
        },
		<!-- CATEGORY EDITING AREA START -->
        'Dieser Ort gefällt mir.': {
            title: 'Was kann man zum Beispiel aufschreiben?',
            text: 'Dieser Ort strahlt eine beruhigende Ruhe aus und bietet eine angenehme Atmosphäre, die zum Entspannen einlädt.  Ob durch seine natürliche Schönheit oder aufregende Aktivitäten, er vermag es, einen positiven Eindruck zu hinterlassen.',
            color: '#FF7043'
        },
        'Hier fühle ich mich unsicher.': {
            title: 'Was kann man zum Beispiel aufschreiben?',
            text: 'Die schlechte Straßenbeleuchtung lässt ein Gefühl der Unsicherheit aufkommen, während betrunkene oder obdachlose Personen die Unbehaglichkeit weiter verstärken.   Hier wäre eine Aufwertung der öffentlichen Infrastruktur und mehr soziale Dienste wünschenswert.',
            color: '#B71C1C'
        },
        'Hier gibt es Probleme mit dem Parken.': {
            title: 'Was kann man zum Beispiel aufschreiben?',
            text: 'Die knappen Parkmöglichkeiten und rücksichtslos abgestellte Fahrzeuge erschweren die Durchfahrt und schaffen ein chaotisches Straßenbild.   Eine bessere Regulierung und Beschilderung könnte hier Abhilfe schaffen.',
            color: '#1565C0'
        },
        'Hier verbringe ich gerne meine Freizeit.': {
            title: 'Was kann man zum Beispiel aufschreiben?',
            text: 'Dieser Ort bietet eine friedliche Oase zum Abschalten oder ein lebendiges Markttreiben, das zum Stöbern einlädt.   Die angenehme Umgebung, sei es ein Bauernmarkt oder ein Kino, macht ihn zu einem beliebten Freizeitziel.',
            color: '#4CAF50'
        },
        'Dieser Ort braucht eine Verbesserung.': {
            title: 'Was kann man zum Beispiel aufschreiben?',
            text: 'Die fehlende Fußgängerüberquerung und der heruntergekommene Anblick, gepaart mit Schlaglöchern im Straßenbelag, rufen nach Verbesserungen.   Eine Aufwertung der Ästhetik und Sicherheit würde den Ort deutlich attraktiver machen.',
            color: '#4E342E'
        },
        'An diesem Ort fehlt ein Service.': {
            title: 'Was kann man zum Beispiel aufschreiben?',
            text: 'Die mangelhafte Busanbindung und geschlossene Apotheken erschweren den Alltag und lassen den Ort weniger serviceorientiert erscheinen.   Eine Verbesserung der öffentlichen Dienstleistungen wäre hier von Vorteil.',
            color: 'white'
        },
		<!-- CATEGORY EDITING AREA END -->

    };

    // Function to create and show the popup
    let popupTimer;
    let buttonTimer;

    function showPopup(info) {
        clearTimeout(popupTimer);
        const existingPopup = document.getElementById("info-popup");
        if (existingPopup) {
            existingPopup.remove();
        }
		
		const popup = document.createElement("div");
popup.id = "info-popup";
popup.style.backgroundColor = isLightMode ? "rgba(244, 244, 237, 1)" : "rgba(17, 17, 17, 1)";
popup.style.color = isLightMode ? "black" : "white";
popup.style.border = "2px solid rgba(0,0,0,0.2)"; // Added border style
popup.style.borderRadius = "30px";
popup.style.position = "absolute";
popup.style.bottom = "10px";
popup.style.right = "10px";
popup.style.marginLeft = "10px";
popup.style.marginTop = "10px";
popup.style.zIndex = "1000";
popup.style.opacity = "0";
popup.style.transition = "opacity 0.2s ease-in";

const title = document.createElement("h3");
title.style.color = info.color;
title.style.fontWeight = "bold";
title.style.fontSize = "24px";
title.innerHTML = info.title;
popup.appendChild(title);

const text = document.createElement("p");
text.style.fontWeight = "bold";
text.style.fontSize = "18px";
text.innerHTML = info.text;
popup.appendChild(text);

// Adjust font size for mobile devices
const adjustFontSizeForMobile = () => {
    const mediaQuery = window.matchMedia("(max-width: 768px)");
    if (mediaQuery.matches) {
        title.style.fontSize = "12px";
        text.style.fontSize = "12px";
    } else {
        title.style.fontSize = "24px";
        text.style.fontSize = "18px";
    }
};

// Listen for changes in screen size
window.addEventListener('resize', adjustFontSizeForMobile);

// Initial adjustment
adjustFontSizeForMobile();

        document.getElementById("map").appendChild(popup);

        popup.addEventListener('click', function (event) {
            event.stopPropagation();
        });

        setTimeout(() => {
            popup.style.opacity = "1";
        }, 0);

        let timeout = 5000;  // Default timeout in milliseconds
        if (info.title === 'Willkommen auf der Stimmungskarte!') {
            timeout = 15000;  // 15 seconds for 'Willkommen' popup
        } else if (info.title === 'Dieses Bild wird ersetzt:') {
            timeout = -1;  // Infinite for 'Overlay' popup
        }
		
		// Check if this is the 'uigif-counter' popup and add a specific class
		if (info.title === 'So funktioniert Filtern:') {
        popup.classList.add('uigif-counter-popup');
		} else if (info.title === 'Größenänderung:') {
        popup.classList.add('admin-pinresize-popup');
} else if (info.title === 'Einzelne Pins löschen:') {
    popup.classList.add('admin-pindelete-popup');

		}
		
        if (!info.persist) {
            clearTimeout(popupTimer);
            popupTimer = setTimeout(() => {
                popup.style.opacity = "0";
                setTimeout(() => {
                    popup.remove();
                }, 500);
            }, timeout);
        }
    }

    function activatePopup() {
        const info = popupTexts['Willkommen auf der Stimmungskarte!'];
        showPopup(info);
    }

    function activatePopupByKey() {
        const info = popupTexts['Login'];
        showPopup(info);

        const loginForm = document.getElementById("loginForm");
        if (loginForm) {
            loginForm.addEventListener("submit", function (event) {
                event.preventDefault();
                const formData = new FormData(loginForm);
                const username = formData.get("username");
                const password = formData.get("password");
                const otp = formData.get("otp");

                fetch("/login", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                    },
                    body: `username=${username}&password=${password}&otp=${otp}`,
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === "success") {
                            const successInfo = popupTexts['Success'];
                            showPopup(successInfo);

                            const imageToHide = document.querySelector(".hide-on-mobile.resistant-image");
                            if (imageToHide) {
                                imageToHide.style.display = 'none';
                            }

                            const h3ElementsToHide = document.querySelectorAll(".resistant-h3");
                            if (h3ElementsToHide) {
                                h3ElementsToHide.forEach((element) => {
                                    element.style.display = 'none';
                                });
                            }

                            const adminTools = document.querySelector(".admintools-container");
                            if (adminTools) {
                                adminTools.style.display = 'block';
                            }
                        } else {
                            alert("Failed: " + data.message);
                        }
                    })
                    .catch(error => {
                        alert("An error occurred: " + error);
                    });
            });
        }
    }
	
// Add new code here
const counterContainer = document.getElementById('counter-container');
let isUIGifCounterPopupVisible = false;
// New code for admin-pindelete
const adminPinDelete = document.getElementById('adminpindelete');
let isAdminPinDeletePopupVisible = false;

if (adminPinDelete) {
    adminPinDelete.addEventListener('mouseover', () => {
        if (!isAdminPinDeletePopupVisible) {
            const adminPinDeleteInfo = popupTexts['admin-pindelete'];
            showPopup(adminPinDeleteInfo);
            isAdminPinDeletePopupVisible = true;
        }
    });

    adminPinDelete.addEventListener('mouseout', () => {
        if (isAdminPinDeletePopupVisible) {
            const existingPopup = document.getElementById("info-popup");
            if (existingPopup) {
                existingPopup.style.opacity = "0";
                setTimeout(() => {
                    existingPopup.remove();
                }, 500);
            }
            isAdminPinDeletePopupVisible = false;
        }
    });
}


     // Add event listeners to the counter-pill element
        const counterPill = document.getElementById('counter-pill'); // Ensure this is the correct ID
        if (counterPill) {
		   // Function to stop event propagation
            function stopPropagation(event) {
                event.stopPropagation();
            }
            counterPill.addEventListener('mouseenter', () => {
                // Show the 'uigif-counter' popup when hovered over
                const uigifCounterInfo = popupTexts['uigif-counter'];
                showPopup(uigifCounterInfo);
            });
 // Add event listeners to stop propagation of mouse events
            ['mousedown', 'mouseup', 'click', 'dblclick'].forEach(eventType => {
                counterPill.addEventListener(eventType, stopPropagation);
            });
            counterPill.addEventListener('mouseleave', () => {
                // Hide the popup when the mouse leaves the counter-pill element
                const existingPopup = document.getElementById("info-popup");
                if (existingPopup) {
                    existingPopup.style.opacity = "0";
                    setTimeout(() => {
                        existingPopup.remove();
                    }, 500);
                }
            });
        }

// New code for admin-pinresize
const adminPinResize = document.getElementById('adminpinresize');
let isAdminPinResizePopupVisible = false;

if (adminPinResize) {
    adminPinResize.addEventListener('mouseover', () => {
        if (!isAdminPinResizePopupVisible) {
            const adminPinResizeInfo = popupTexts['admin-pinresize'];
            showPopup(adminPinResizeInfo);
            isAdminPinResizePopupVisible = true;
        }
    });

    adminPinResize.addEventListener('mouseout', () => {
        if (isAdminPinResizePopupVisible) {
            const existingPopup = document.getElementById("info-popup");
            if (existingPopup) {
                existingPopup.style.opacity = "0";
                setTimeout(() => {
                    existingPopup.remove();
                }, 500);
            }
            isAdminPinResizePopupVisible = false;
        }
    });
}

    let isOverlayPopupVisible = false;

    window.toggletitelbildMenu = function () {
        var titelbildMenu = document.getElementById('titelbild-menu');
        if (titelbildMenu.style.display === 'none') {
            titelbildMenu.style.display = 'block';
            const overlayInfo = popupTexts['Overlay'];
            showPopup(overlayInfo);
            isOverlayPopupVisible = true;
        } else {
            titelbildMenu.style.display = 'none';
            if (isOverlayPopupVisible) {
                const existingPopup = document.getElementById("info-popup");
                if (existingPopup) {
                    existingPopup.style.opacity = "0";
                    setTimeout(() => {
                        existingPopup.remove();
                    }, 500);
                }
                isOverlayPopupVisible = false;
            }
        }
    };
	

	
	// New code for infoDiv
    const infoDiv = document.getElementById('infoDiv');
    if (infoDiv) {
        infoDiv.addEventListener('click', () => {
            window.open('https://stimmungskompass.at', '_blank');
        });
    }


    const keyDiv = document.querySelector("#keyDiv");
    if (keyDiv) {
        keyDiv.addEventListener("click", activatePopupByKey);
    }

    const buttonS = document.querySelector(".button-s");
    if (buttonS) {
        buttonS.addEventListener("click", activatePopup);
    }

    const categorybuttons = document.querySelectorAll(".categorybutton");
    categorybuttons.forEach(menu => {
        menu.addEventListener("click", (event) => {
            const title = event.currentTarget.querySelector("h3").textContent;
            const info = popupTexts[title];
            showPopup(info);
        });
    });
});
  </script>
<?php BOTTOM RIGHT CORNER INFOPOPUP LOGIC END ?>
<script>
    (function() {
        function handleLogin() {
            var username = document.getElementById('username').value;
            var password = document.getElementById('password').value;
            var otp_token = document.getElementById('otp').value;

            var xhr = new XMLHttpRequest();
            xhr.open('POST', '/login', true);
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            xhr.onload = function() {
                if (this.status === 200) {
                    loadAdminTools();
                } else {
                    console.error('Login failed:', this.responseText);
                }
            };
            xhr.onerror = function() {
                console.error("Request failed.");
            };
            xhr.send(`username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}&otp=${encodeURIComponent(otp_token)}`);
        }

        function loadAdminTools() {
    console.log("Attempting to load admin tools...");

    var xhr = new XMLHttpRequest();
    xhr.open('GET', '/admintools', true);
    xhr.onload = function() {
        if (this.status === 200) {
            console.log('Admin tools loaded successfully.');
            var dynamicArea = document.getElementById('dynamicgeneration-admintools');
            dynamicArea.innerHTML = this.responseText;



                 // Call the initialization function here
            initializeAdminTools();
        } else {
            console.error('Failed to load admin tools:', this.statusText);
        }
    };
    xhr.onerror = function() {
        console.error("Request failed.");
    };
    xhr.send();
}
       function initializeAfterAdminToolsLoad() {
        console.log('Initializing elements after loading admin tools.');
        if (document.getElementById('category-select')) {
            initializeRecolorFunctionality();
        }
        if (document.getElementById('delete-category-select')) {
            initializeDeleteCategoryDropdown();
        }
        if (document.getElementById('deleteCategory')) {
            initializeDeleteCategoryButton();
        }
        updateAllCategoryDropdowns();
    }
	
	function initializeAdminTools() {
    console.log("Initializing Admin Tools...");

    // Populate category dropdowns
    populateCategoryDropdowns();

    // Initialize all features
    initializeRecolorFunctionality();
    initializeCategoryRenameFunctionality();
    initializeCategoryCreationFunctionality();
    initializeCategoryDeletionFunctionality();

    // Delete objects by category
    const deleteCategoryObjectsButton = document.getElementById('delete-category-objects');
    if (deleteCategoryObjectsButton) {
        deleteCategoryObjectsButton.addEventListener('click', deleteObjectsByCategory);
    }

    // Delete objects by object type
    const deleteObjectTypeObjectsButton = document.getElementById('delete-object-type-objects');
    if (deleteObjectTypeObjectsButton) {
        deleteObjectTypeObjectsButton.addEventListener('click', deleteObjectsByObjectType);
    }

    console.log("Admin Tools Initialized Successfully");
}


// Function to populate all category dropdowns
function populateCategoryDropdowns() {
    console.log("Populating Category Dropdowns...");
    fetch('/get-categories')
        .then(response => response.json())
        .then(categories => {
            updateDropdowns(categories, ['category-select', 'rename-category-select', 'delete-category-select']);
            console.log("Category Dropdowns Populated Successfully");
        })
        .catch(error => {
            console.error('Error fetching categories:', error);
        });
}



// Utility function to update dropdowns
function updateDropdowns(categories, dropdownIds) {
    dropdownIds.forEach(dropdownId => {
        const dropdown = document.getElementById(dropdownId);
        if (dropdown) {
            dropdown.innerHTML = ''; // Clear existing options
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category.text;
                option.textContent = category.text;
                dropdown.appendChild(option);
            });
        } else {
            console.error(`Dropdown with ID ${dropdownId} not found.`);
        }
    });
}

// Function to initialize the rename category functionality
function initializeCategoryRenameFunctionality() {
    // Fetch categories and populate the rename dropdown
    fetch('/get-categories')
    .then(response => response.json())
    .then(categories => {
        const renameDropdown = document.getElementById('rename-category-select');
        renameDropdown.innerHTML = ''; // Clear existing options

        categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.color; // Assuming 'color' is the identifier
            option.textContent = category.text;
            renameDropdown.appendChild(option);
        });
    });

    // Event listener for the rename button
    const renameButton = document.getElementById('rename-category');
    if (renameButton) {
        renameButton.addEventListener('click', function() {
            var color = document.getElementById('rename-category-select').value;
            var newName = document.getElementById('rename-category-name').value.trim();
            if (newName === "") {
                console.error('New category name is required');
                return;
            }
            console.log(`Renaming category ${color} to ${newName}`);
            
            fetch('/rename-category', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ color: color, newName: newName })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(result => {
                console.log('Category renamed successfully:', result);
                // Optionally refresh the categories in the dropdown and other related UI
            })
            .catch(error => {
                console.error('Error renaming category:', error);
            });
        });
    }
}
	
function initializeRecolorFunctionality() {
    // Fetch categories and populate the recolor dropdown
    fetch('/get-categories')
    .then(response => response.json())
    .then(categories => {
        const recolorDropdown = document.getElementById('category-select');
        recolorDropdown.innerHTML = ''; // Clear existing options

        categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.color; // Assuming 'color' is the identifier
            option.textContent = category.text;
            recolorDropdown.appendChild(option);
        });
    });

    // Event listener for the recolor button
    const recolorButton = document.getElementById('update-color');
    if (recolorButton) {
        recolorButton.addEventListener('click', function() {
            var selectedCategory = document.getElementById('category-select').value;
            var newColor = document.getElementById('color-picker').value;

            fetch('/update-category', { // Ensure this matches your Flask route
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ oldColor: selectedCategory, newColor: newColor })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(result => {
                console.log('Category recolored:', result);
                // Optionally update the UI to reflect the color change
            })
            .catch(error => {
                console.error('Error recoloring category:', error);
            });
        });
    }
}
function initializeCategoryCreationFunctionality() {
    // Event listener for the create category button
    const createCategoryButton = document.getElementById('create-category'); // Adjust the ID as needed
    if (createCategoryButton) {
        createCategoryButton.addEventListener('click', function() {
            var categoryName = document.getElementById('create-category-name').value.trim(); // Adjust the ID as needed
            var categoryColor = document.getElementById('create-category-color').value; // Adjust the ID as needed

            if (categoryName === "") {
                console.error('Category name is required');
                return;
            }

            fetch('/create-category', { // Ensure this matches your Flask route
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ name: categoryName, color: categoryColor })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(result => {
                console.log('Category created successfully:', result);
                // Optionally update the UI to reflect the new category
            })
            .catch(error => {
                console.error('Error creating category:', error);
            });
        });
    }
}

// Function to fetch categories and populate the deletion dropdown
function fetchCategoriesForDeletion() {
    fetch('/get-categories')
    .then(response => response.json())
    .then(categories => {
        const categorySelect = document.getElementById('delete-category-select');
        categorySelect.innerHTML = ''; // Clear existing options
        categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.color; // Assuming 'color' is the identifier
            option.textContent = category.text;
            categorySelect.appendChild(option);
        });
    });
}

// Function to initialize the delete category functionality
function initializeCategoryDeletionFunctionality() {
    fetchCategoriesForDeletion(); // Populate the dropdown

    const deleteCategoryButton = document.getElementById('delete-category');
    if (deleteCategoryButton) {
        deleteCategoryButton.addEventListener('click', function() {
            var selectedCategory = document.getElementById('delete-category-select').value;

            fetch('/delete-category', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ color: selectedCategory })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(result => {
                console.log('Category deleted successfully:', result);
                fetchCategoriesForDeletion(); // Refresh the dropdown
            })
            .catch(error => {
                console.error('Error deleting category:', error);
            });
        });
    }
}

// Function to initialize the delete category dropdown
   // Initialize Delete Category Dropdown
    function initializeDeleteCategoryDropdown() {
        fetch('/get-categories')
        .then(response => response.json())
        .then(categories => {
            var dropdown = document.getElementById('delete-category-select');
            dropdown.innerHTML = ''; // Clear existing options
            
            categories.forEach(function(category) {
                var option = document.createElement('option');
                option.value = option.text = category.name; // Assuming 'name' is the correct property
                dropdown.appendChild(option);
            });
        })
        .catch(error => {
            console.error('Error fetching categories:', error);
        });
    }

function deleteObjectsByCategory() {
    var color = document.getElementById('delete-category-select').value;
    console.log(`Deleting objects with category color ${color}`);

    fetch('/delete-objects-by-category', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ color: color })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(result => {
        console.log('Objects deleted successfully:', result);
        fetchCategoriesForDeletion(); // Refresh the categories in the dropdowns
    })
    .catch(error => {
        console.error('Error deleting objects by category:', error);
    });
}

function deleteObjectsByObjectType() {
    var objectType = document.getElementById('delete-object-type-select').value;
    console.log(`Deleting objects of type ${objectType}`);

    fetch('/delete-objects-by-object-type', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ objectType: objectType })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(result => {
        console.log('Objects deleted successfully:', result);
        // Optionally refresh the map or shapes to reflect the deletion
    })
    .catch(error => {
        console.error('Error deleting objects by object type:', error);
    });
}

// Function to initialize the delete button
function initializeDeleteCategoryButton() {
  var deleteButton = document.getElementById('deleteCategory');
  deleteButton.addEventListener('click', function() {
    var selectedCategory = document.getElementById('delete-category-select').value;

    fetch('/delete-category', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ categoryName: selectedCategory })
    })
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      return response.json();
    })
    .then(result => {
      console.log('Category deleted:', result);
      initializeDeleteCategoryDropdown(); // Re-initialize the dropdown
      refreshCategoriesDisplay(); // Refresh the categories displayed on the page
    })
    .catch(error => {
      console.error('Error deleting category:', error);
    });
	    updateAllCategoryDropdowns();
  });
}

    function updateAllCategoryDropdowns() {
    console.log('Fetching categories from: /get-categories');

    fetch('/get-categories')
        .then(response => response.json())
        .then(categories => {
            const dropdowns = [
                document.getElementById('rename-category-select'),
                document.getElementById('category-select'),
                document.getElementById('delete-category-select')
            ];

            dropdowns.forEach(dropdown => {
                if (dropdown) {
                    let currentValue = dropdown.value; // Store current value to restore it later
                    dropdown.innerHTML = ''; // Clear existing options

                    categories.forEach(category => {
                        const option = document.createElement('option');
                        option.value = option.textContent = category.text;
                        dropdown.appendChild(option);
                    });

                    dropdown.value = currentValue; // Restore the previously selected value
                } else {
                    console.error('Dropdown element not found in the DOM.');
                }
            });
        })
        .catch(error => {
            console.error('Error fetching categories:', error);
        });
		}

    window.handleLogin = handleLogin;
})();

  </script>
<?php ADMINTOOLS CATEGORIES TOGGLING START ?>
    <script>
document.addEventListener('DOMContentLoaded', function() {
    document.body.addEventListener('click', function(event) {
        if (event.target.id === 'toggle-category-menu') {
            var categoryMenu = document.getElementById('category-menu');
            categoryMenu.style.display = categoryMenu.style.display === 'none' ? 'block' : 'none';
        }
    });
});

    </script>
	

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Event delegation for dynamically loaded content
    document.body.addEventListener('click', function(event) {
        if (event.target.id === 'toggle-category-menu2') {
            var categoryMenu = document.getElementById('category-menu');
            categoryMenu.style.display = categoryMenu.style.display === 'none' ? 'block' : 'none';
        } else if (event.target.id === 'toggle-rename-category') {
            var renameCategoryContent = document.getElementById('rename-category-content');
            renameCategoryContent.style.display = renameCategoryContent.style.display === 'none' ? 'block' : 'none';
        } else if (event.target.id === 'toggle-create-category') {
            var createCategoryContent = document.getElementById('create-category-content');
            createCategoryContent.style.display = createCategoryContent.style.display === 'none' ? 'block' : 'none';
        }
    });
});
</script>
	
<script>
   function toggleHeatmapMenu() {
  var heatmapSettings = document.getElementById("heatmapSettings");
  if (heatmapSettings.style.display === "none" || heatmapSettings.style.display === "") {
    heatmapSettings.style.display = "block";
  } else {
    heatmapSettings.style.display = "none";
  }
}
  </script>
<script>
   function toggleEditorMenu() {
        var editorMenu = document.getElementById('editor-menu');
        if (editorMenu.style.display === 'none') {
            editorMenu.style.display = 'block';
        } else {
            editorMenu.style.display = 'none';
        }
    }
  </script>
<script>
   function togglePinsExportMenu() {
        var menu = document.getElementById('pinsexport-menu');
        var button = document.getElementById('pinsexport-menu-button');
        if (menu.style.display === 'none' || menu.style.display === '') {
            menu.style.display = 'block';
        } else {
            menu.style.display = 'none';
            button.classList.remove('toggled');
        }
    }
  </script>
<?php ADMINTOOLS CATEGORIES TOGGLING END ?>
<script>
    // Assuming jQuery is included
    
    var shapeLayersByColor = {};
    var shapeLayersByType = {};
    var colorVisibilityState = {};
    var typeVisibilityState = {};

    // Initialize visibility state dictionaries
    function initializeVisibilityStates() {
        var colors = {{ color_counts | tojson }};
        console.log("Parsed color data:", colors);

        var types = {{ category_counts | tojson }};
        console.log("Parsed category data:", types);

        Object.keys(colors).forEach(function(color) {
            colorVisibilityState[color] = true; // All colors visible by default
            console.log('Initialized visibility state for color', color);
        });
        Object.keys(types).forEach(function(type) {
            typeVisibilityState[type] = true; // All types visible by default
            console.log('Initialized visibility state for type', type);
        });
    }

    // Function to update visibility based on both color and type
    function updateVisibility(layer, color, type) {
        var visibleByColor = color ? colorVisibilityState[color] : true; // Default to true if color is undefined
        var visibleByType = typeVisibilityState[type]; // The visibility state of the type
        console.log('Updating visibility for layer. Color:', color, 'Type:', type, 'Visible by Color:', visibleByColor, 'Visible by Type:', visibleByType);

        // Change visibility only if both color and type visibility are true
        if (visibleByColor && visibleByType) {
            if (!map.hasLayer(layer)) {
                map.addLayer(layer);
                console.log('Layer shown on map:', layer);
            }
        } else {
            if (map.hasLayer(layer)) {
                map.removeLayer(layer);
                console.log('Layer removed from map:', layer);
            }
        }
    }

 // Enhanced addLayer function
function addLayer(layer, color, type) {
    console.log('Attempting to add layer:', layer, 'Color:', color, 'Type:', type);

    // Add to color dictionary
    if (!shapeLayersByColor[color]) {
        shapeLayersByColor[color] = [];
    }
    shapeLayersByColor[color].push(layer);

    // Check if type is defined before adding to type dictionary
    if (type) {
        if (!shapeLayersByType[type]) {
            shapeLayersByType[type] = [];
        }
        shapeLayersByType[type].push(layer);
    }

    console.log(`Layer added. Current state by color:`, shapeLayersByColor, `Current state by type:`, shapeLayersByType);
}

    // Modify the toggleVisibility function to handle shapes without a defined type
    function toggleVisibility(color) {
        console.log('Toggling visibility for color:', color);
        colorVisibilityState[color] = !colorVisibilityState[color];
        console.log(`Visibility state for color '${color}' is now:`, colorVisibilityState[color]);
        if (shapeLayersByColor[color]) {
            console.log(`Found layers for color '${color}'. Processing...`);
            shapeLayersByColor[color].forEach(function(layer) {
                var type = layer.options.shapeType || undefined; // Use undefined if shapeType isn't set
                console.log('Updating visibility for layer. Layer:', layer, 'Color:', color, 'Type:', type);
                updateVisibility(layer, color, type);
            });
        } else {
            console.log('No layers found for color:', color);
        }
    }

    // Enhanced toggleVisibilityByType function
    function toggleVisibilityByType(type) {
        console.log('Toggling visibility for type:', type);
        typeVisibilityState[type] = !typeVisibilityState[type];
        console.log(`Visibility state for type '${type}' is now:`, typeVisibilityState[type]);
        if (shapeLayersByType[type]) {
            console.log(`Found layers for type '${type}'. Processing...`);
            shapeLayersByType[type].forEach(function(layer) {
                var color = layer.options.color || layer.options.shapeColor; // Assume each layer has a color or shapeColor property
                console.log('Updating visibility for layer. Layer:', layer, 'Color:', color, 'Type:', type);
                updateVisibility(layer, color, type);
            });
        } else {
            console.log('No layers found for type:', type);
        }
    }

    
    $(document).ready(function() {
        // Initialize visibility states when the document is ready
        initializeVisibilityStates();

        // Load shapes from the database and add to the map and dictionaries
        
// Load shapes from the database and add to map and dictionaries
$.getJSON('/api/shapes', function(data) {
    data.shapes.forEach(function(shape) {
        console.log('Loading shape from database:', shape);

        // Create a layer from the shape data
        var layer = L.geoJSON(shape.shape_data); // Modify according to actual layer creation logic

        // Ensure shape_type is correctly set in your database and here
        var layerType = shape.shape_type || 'defaultType'; // Provide a default type if undefined

        // Add the loaded shape to dictionaries
        addLayer(layer, shape.shape_color, layerType);

        // Additional logic to add the layer to the map, if necessary
    });
    console.log('All shapes loaded from the database and added to dictionaries.');
});
		
        var colorCounts = {{ color_counts | tojson }};
        console.log('Color counts:', colorCounts);

        Object.entries(colorCounts).forEach(([color, count]) => {
            var colorCircle = $(`<span class="counter-color" style="background-color: ${color}; border: 2px solid white;"></span>`);
            var listItem = $(`<li style="margin-right: 5px;">`).append(colorCircle).append(` ${count}`);
            listItem.on('click', function() {
                console.log('Clicked color:', color);

                toggleVisibility(color);
                // Dim the circle by adjusting the opacity
                if (colorCircle.css('opacity') == '1') {
                    colorCircle.css('opacity', '0.5'); // Dim it
                } else {
                    colorCircle.css('opacity', '1'); // Return to full opacity
                }
            });
            $('#color-counters').append(listItem);
        });

        // Populate category counters
        var categoryCounts = {{ category_counts | tojson }};
        console.log('Category counts:', categoryCounts);

        Object.entries(categoryCounts).forEach(([category, count]) => {
            var symbol = '';
            switch(category) {
			    case 'marker': symbol = '<img src="static/popupmenu_marker_darkmode.png" style="border: 1px solid white;"   alt="Marker" class="category-symbol" />'; break;
                case 'circle': symbol = '<img src="static/popupmenu_circle_darkmode.png" style="border: 1px solid white;"  alt="Circle" class="category-symbol" />'; break;
				case 'rectangle': symbol = '<img src="static/popupmenu_rectangle_darkmode.png" style="border: 1px solid white;"   alt="Rectangle" class="category-symbol" />'; break;
                case 'polygon': symbol = '<img src="static/popupmenu_polygon_darkmode.png" style="border: 1px solid white;" alt="Polygon" class="category-symbol" />'; break;
                // Add more cases for other categories if necessary
            }
            $('#category-counters').append(
                $(`<li style="margin-right: 5px;">`).append(
                    $(symbol).on('click', function() {
                        toggleVisibilityByType(category);
                        // Dim the symbol by adjusting the opacity
                        $(this).css('opacity', $(this).css('opacity') == '1' ? '0.5' : '1');
                    })
                ).append(` ${count}`)
            );
        });

        console.log("Counters displayed.");
    });
</script>

<script>
// Fetch and display all objects and populate filters when the page loads
document.addEventListener('DOMContentLoaded', function() {
    fetch('/api/all-shapes').then(response => response.json()).then(data => {
        console.log('Objects loaded from the database:', data.shapes);
        displayObjects(data.shapes);
        populateColorFilter(data.shapes);
    });
});

// Populate color filter options
function populateColorFilter(shapes) {
    const colorSet = new Set(shapes.map(shape => shape.shape_color));
    const colorFilter = document.getElementById('color-filter');
    colorSet.forEach(color => {
        if (color) { // ensure that null or undefined colors are not added
            const option = document.createElement('option');
            option.value = color;
            option.textContent = color;
            colorFilter.appendChild(option);
        }
    });
}


// Display objects in the list
function displayObjects(objects) {
    const objectList = document.getElementById('object-list');
    objectList.innerHTML = ''; // Clear the current list
    objects.forEach(object => {
        console.log('Processing object:', object); // Debugging
        const objectDiv = document.createElement('div');
        objectDiv.style.display = 'flex';
        objectDiv.style.alignItems = 'center'; // Align items vertically

            // Create a colored circle for the object
        const colorCircle = document.createElement('span');
        colorCircle.style.width = '20px';
        colorCircle.style.height = '20px';
        colorCircle.style.borderRadius = '50%';
		        colorCircle.style.border = '2px solid white';
        colorCircle.style.backgroundColor = object.shape_color;
        colorCircle.style.display = 'inline-block';
        colorCircle.style.marginRight = '5px';
        colorCircle.style.flexShrink = '0'; // Prevent circle from shrinking

        objectDiv.appendChild(colorCircle);

        // Add emoji based on shape type
        const shapeTypeEmoji = document.createElement('span');
        shapeTypeEmoji.style.marginRight = '5px';
        shapeTypeEmoji.style.fontSize = '20px';
        switch (object.shape_type) {
            case 'marker':
                shapeTypeEmoji.textContent = '📍'; // Pin emoji
                break;
            case 'rectangle':
                shapeTypeEmoji.textContent = '◼️'; // Rectangle emoji
                break;
            case 'circle':
                shapeTypeEmoji.textContent = '⚪'; // Circle emoji
                break;
            case 'polygon':
                shapeTypeEmoji.textContent = '🔺'; // Triangle (used as a polygon) emoji
                break;
            // Add more cases for other shape types if needed
        }
        objectDiv.appendChild(shapeTypeEmoji);

              // Create a span for the shape note
        const shapeNote = document.createElement('span');
        shapeNote.textContent = `${object.shape_note}`;

        // Determine the current mode by checking the class
        const currentMode = document.documentElement.classList.contains('light-mode') ? 'light' : 'dark';
        shapeNote.style.color = currentMode === 'light' ? 'black' : 'white';

        objectDiv.appendChild(shapeNote);

        // Add hover event to center map on object location
        objectDiv.addEventListener('mouseenter', () => centerMapOnObject(object));

        // Add delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.addEventListener('click', () => deleteObject(object.id));
        objectDiv.appendChild(deleteBtn);

        objectList.appendChild(objectDiv);
    });
}
	
// Function to fetch shapes and calculate the center of mass
// Function to center map on a specific object's location
function centerMapOnObject(object) {
    console.log(`Centering map on object: ${object.id}`);

    if (object.shape_data && object.shape_data.coordinates) {
        const lat = object.shape_data.coordinates[1]; // Assuming format [lng, lat]
        const lng = object.shape_data.coordinates[0];
        map.setView([lat, lng], 13); // Adjust the zoom level as needed
    } else {
        console.error('Object does not have valid coordinates:', object);
    }
}
objectDiv.addEventListener('mouseenter', () => centerMapOnObject(object));




	// Function to delete an object
	function deleteObject(objectId) {
		console.log(`Deleting object: ${objectId}`);
		fetch(`/api/delete-object/${objectId}`, { method: 'DELETE' })
			.then(response => response.json())
			.then(data => {
				if (data.success) {
					console.log(`Object ${objectId} deleted successfully.`);
					// Refresh the object list
					fetch('/api/all-shapes').then(response => response.json()).then(data => {
						displayObjects(data.shapes);
					});
				} else {
					console.error(`Failed to delete object ${objectId}.`);
				}
			});
	}

        // Function to filter objects based on the search input and selected filters
        function filterObjects() {
            const searchQuery = document.getElementById('search-box').value.toLowerCase();
            const colorFilter = document.getElementById('color-filter').value;
            const typeFilter = document.getElementById('type-filter').value;

            fetch('/api/shapes').then(response => response.json()).then(data => {
                let filteredObjects = data.shapes;

                // Filter by color if a color is selected
                if (colorFilter) {
                    filteredObjects = filteredObjects.filter(object => object.shape_color === colorFilter);
                }

                // Filter by object type if a type is selected
                if (typeFilter) {
                    filteredObjects = filteredObjects.filter(object => object.shape_type === typeFilter);
                }

                // Filter by note based on search query
                if (searchQuery) {
                    filteredObjects = filteredObjects.filter(object => object.shape_note.toLowerCase().includes(searchQuery));
                }

                displayObjects(filteredObjects);
            });
        }
  </script>
<script>
   function toggleSearchFilter() {
    var searchFilterSection = document.getElementById('search-filter-section');
    var overlayImage = document.getElementById('overlay-image');

    // Toggle the search and filter section
    if (searchFilterSection.style.display === 'none') {
        searchFilterSection.style.display = 'block';
    } else {
        searchFilterSection.style.display = 'none';
    }

    // Toggle the overlay image, but ensure it still hides on mobile
    if (window.getComputedStyle(overlayImage).display === 'none') {
        overlayImage.style.display = 'block';
    } else {
        overlayImage.style.display = 'none';
    }
}
  </script>

<script>
// Event delegation to handle clicks on category buttons
document.addEventListener('click', function(e) {
    // Check if the clicked element has the 'categorybutton' class
    if (e.target.classList.contains('categorybutton')) {
        // Remove 'selected' class from all category buttons
        document.querySelectorAll('.categorybutton').forEach(function(btn) {
            btn.classList.remove('selected');
        });

        // Add 'selected' class to the clicked button
        e.target.classList.add('selected');
    }
});
</script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const iframe = document.getElementById('categories-iframe');

    // Combined function to adjust iframe height and show buttons
    function adjustIframeHeightAndShowButtons() {
        const overlayImage = document.getElementById('overlay-image');
        const overlayBottom = overlayImage.getBoundingClientRect().bottom;
        const availableHeight = window.innerHeight - overlayBottom;

        // Set the height of the iframe
        iframe.style.height = availableHeight + 'px';

        // Call function inside iframe to adjust padding
        if (iframe.contentWindow.adjustButtonPadding) {
            iframe.contentWindow.adjustButtonPadding();
        }

        // Make the buttons visible
        if (iframe.contentWindow.makeButtonsVisible) {
            iframe.contentWindow.makeButtonsVisible();
        }
    }

    // Set the onload event handler for the iframe
    iframe.onload = adjustIframeHeightAndShowButtons;

    // Call the function once on load and on resize
    adjustIframeHeightAndShowButtons();
    window.addEventListener('resize', adjustIframeHeightAndShowButtons);
});
</script>

<div id="popup-container"></div>

  <script>
    $(document).ready(function() {
      if (!getCookie('hidePopup')) {
        $('#popup-container').load('/popup_content.html', function() {
          // Popup content loaded
          $('#popup-container').find('#dismiss-popup').click(function() {
            setCookie('hidePopup', 'true', 7); // Hide for 7 days
            $('#popup-container').hide();
          });
        });
      }
    });

    function setCookie(name, value, days) {
      var expires = "";
      if (days) {
        var date = new Date();
        date.setTime(date.getTime() + (days*24*60*60*1000));
        expires = "; expires=" + date.toUTCString();
      }
      document.cookie = name + "=" + (value || "")  + expires + "; path=/";
    }

    function getCookie(name) {
      var nameEQ = name + "=";
      var ca = document.cookie.split(';');
      for(var i=0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ') c = c.substring(1,c.length);
        if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
      }
      return null;
    }
  </script>

</body>
</html>
